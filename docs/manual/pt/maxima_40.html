<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezembro, 9 2014 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima 5.35.0: 40. Fluxo de Programa</title>

<meta name="description" content="Manual do Maxima 5.35.0: 40. Fluxo de Programa">
<meta name="keywords" content="Manual do Maxima 5.35.0: 40. Fluxo de Programa">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Fluxo-de-Programa"></a>
<a name="SEC162"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_39.html#SEC161" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC163" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC155" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 40. Fluxo de Programa </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC163">40.1 Introdução a Fluxo de Programa</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC164">40.2 Definições para Fluxo de Programa</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Fluxo-de-Programa"></a>
<a name="SEC163"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC162" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC164" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC162" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC162" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 40.1 Introdução a Fluxo de Programa </h2>

<p>Maxima fornece um <code>do</code> para ciclos iterativos, também contruções mais
primitivas tais como <code>go</code>.
</p>
<hr size="6">
<a name="Defini_00e7_00f5es-para-Fluxo-de-Programa"></a>
<a name="SEC164"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC163" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC162" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC162" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 40.2 Definições para Fluxo de Programa </h2>

<dl>
<dt><u>Função:</u> <b>backtrace</b><i> ()</i>
<a name="IDX1353"></a>
</dt>
<dt><u>Função:</u> <b>backtrace</b><i> (<var>n</var>)</i>
<a name="IDX1354"></a>
</dt>
<dd><p>Imprime a pilha de chamadas, que é, a lista de funções que
foram chamadas pela função correntemente activa.
</p>
<p><code>backtrace()</code> imprime toda a pilha de chamadas.
</p>
<p><code>backtrace (<var>n</var>)</code> imprime as <var>n</var> mais recentes chamadas a
funções, incluindo a função correntemente activa.
</p>
<p><code>backtrace</code> pode ser chamada por um script, uma função, ou a partir da linha de comando interativa
(não somente em um contexto de depuração).
</p>
<p>Exemplos:
</p>
<ul>
<li>
<code>backtrace()</code> imprime toda a pilha de chamadas.

<pre class="example">(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
</pre></li></ul>

<ul>
<li>
<code>backtrace (<var>n</var>)</code> imprime as <var>n</var> mais recentes chamadas a
funções, incluindo a função correntemente activa.

<pre class="example">(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
</pre></li></ul>

</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>do</b>
<a name="IDX1355"></a>
</dt>
<dd><p>A declaração <code>do</code> é usada para executar iteração.  Devido à sua
grande generalidade a declaração <code>do</code> será  descrita em duas partes.
Primeiro a forma usual será dada que é análoga à forma que é usada em
muitas outras linguagens de programação (Fortran, Algol, PL/I, etc.); em segundo lugar
os outros recursos serão mencionados.
</p>
<p>Existem três variantes do operador especial <code>do</code> que diferem somente por suas
condições de encerramento.  São elas:
</p>
<ul>
<li>
<code>for <var>Variável</var>: <var>valor_inicial</var> step <var>incremento</var>
      thru <var>limite</var> do <var>corpo</var></code>
</li><li>
<code>for <var>Variável</var>: <var>valor_inicial</var> step <var>incremento</var>
      while <var>condition</var> do <var>corpo</var></code>
</li><li>
<code>for <var>Variável</var>: <var>valor_inicial</var> step <var>incremento</var>
      unless <var>condition</var> do <var>corpo</var></code>
</li></ul>

<p>(Alternativamente, o <code>step</code> pode ser dado após a condição de encerramento
ou limite.)
</p>
<p><var>valor_inicial</var>, <var>incremento</var>, <var>limite</var>, e <var>corpo</var> podem ser quaisquer
expressões.  Se o incremento for 1 então &quot;<code>step 1</code>&quot; pode ser omitido.
</p>
<p>A execução da declaração <code>do</code> processa-se primeiro atribuindo o
valor_inicial para a variável (daqui em diante chamada a
variável de controle).  Então: (1) Se a variável de controle excede
o limite de uma especificação <code>thru</code>, ou se a condição de <code>unless</code> for
<code>true</code>, ou se a condição de <code>while</code> for <code>false</code> então o <code>do</code>
será encerrado.  (2) O corpo é avaliado.  (3) O incremento é adicionado à
variável de controle.  O processo de (1) a (3) é executado
repetidamente até que a condição de encerramento seja satisfeita.  Pode-se também
dar muitas condições de encerramento e nesse caso o <code>do</code> termina
quando qualquer delas for satisfeita.
</p>
<p>Em geral o teste <code>thru</code> é satisfeito quando a variável de controle for
maior que o limite se o incremento for não negativo, ou quando a
variável de controle for menor que o limite se o incremento for negativo.
O incremento e o limite podem ser expressões não numéricas enquanto essa
desigualdade puder ser determinada.  Todavia, a menos que o incremento seja
sintaticamente negativo (e.g. for um número negativo) na hora em que a declaração <code>do</code>
for iniciada, Maxima assume que o incremento e o limite serão positivos quando o <code>do</code> for
executado.  Se o limite e o incremento não forem positivos, então o <code>do</code> pode não terminar
propriamente.
</p>
<p>Note que o limite, incremento, e condição de encerramento são
avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer desses for responsável por
muitos cálculos, e retornar um resultado que não muda durante todas
as execuções do corpo, então é mais eficiente escolher uma
variável para seu valor anterior para o <code>do</code> e usar essa variável na
forma <code>do</code>.
</p>
<p>O valor normalmente retornado por uma declaração <code>do</code> é o átomo <code>done</code>.
Todavia, a função
<code>return</code> pode ser usada dentro do corpo para sair da delcaração <code>do</code> prematuramente e dar
a isso qualquer valor desejado.
Note todavia que um <code>return</code> dentro de um <code>do</code> que
ocorre em um <code>block</code> encerrará somente o <code>do</code> e não o <code>block</code>.  Note também
que a função <code>go</code> não pode ser usada para sair de dentro de um <code>do</code> dentro de um
<code>block</code> que o envolve.
</p>
<p>A variável de controle é sempre local para o <code>do</code> e dessa forma qualquer
variável pode ser usada sem afectar o valor de uma variável com
o mesmo nome fora da declaração <code>do</code>.  A variável de controle é liberada
após o encerramento da declaração <code>do</code>.
</p>
<pre class="example">(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
</pre>
<pre class="example">(%i1) s: 0$
(%i2) for i: 1 while i &lt;= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
</pre>
<p>Note que a condição <code>while i &lt;= 10</code>
é equivalente a <code>unless i &gt; 10</code> e também <code>thru 10</code>.
</p>
<pre class="example">(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p &gt; 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
</pre>
<p>que fornece 8 termos da série de Taylor para <code>e^sin(x)</code>.
</p>
<pre class="example">(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) &lt; 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
</pre>
<p>Esse exemplo calcula a raíz quadrada negativa de 10 usando a
iteração de Newton- Raphson um maximum de 10 vezes.  Caso o critério de
convergêcia não tenha sido encontrado o valor retornado pode ser <code>done</code>.
Em lugar de sempre adicionar uma quantidade à variável de controle pode-se
algumas vezes desejar alterar isso de alguma outra forma para cada iteração.
Nesse caso pode-se usar <code>next <var>expressão</var></code> em lugar de <code>step <var>incremento</var></code>.
Isso fará com que a variável de controle seja escolhida para o
resultado da expressão de avaliação cada vez que o ciclo de repetição for executado.
</p>
<pre class="example">(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
</pre>
<p>Como uma alternativa para <code>for <var>Variável</var>: <var>valor</var> ...do...</code> a sintaxe
<code>for <var>Variável</var> from <var>valor</var> ...do...</code>  pode ser usada.  Isso permite o
<code>from <var>valor</var></code> ser colocado após o <code>step</code> ou proximo valor ou após a
condição de encerramento.  Se <code>from <var>valor</var></code> for omitido então 1 é usado como
o valor inicial.
</p>
<p>Algumas vezes se pode estar interessado em executar uma iteração onde
a variável de controle nunca seja usada.  Isso é permissível
para dar somente as condições de encerramento omitindo a inicialização
e a informação de actualização como no exemplo seguinte para para calcular a
raíz quadrada de 5 usando uma fraca suposição inicial.
</p>
<pre class="example">(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
</pre>
<p>Se isso for desejado pode-se sempre omitir as condições de encerramento
inteiramente e apenas dar o corpo <code>do <var>corpo</var></code> que continuará a ser 
avaliado indefinidamente.  Nesse caso a função <code>return</code> será usada para
encerrar a execução da declaração <code>do</code>.
</p>
<pre class="example">(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) &lt; 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
</pre>
<p>(Note que <code>return</code>, quando executado, faz com que o valor corrente de
<code>x</code> seja retornado como o valor da declaração <code>do</code>.  O <code>block</code> é encerrado e
esse valor da declaração <code>do</code> é retornado como o valor do <code>block</code> porque o
<code>do</code> é a última declaração do <code>block</code>.)
</p>
<p>Uma outra forma de <code>do</code> é disponível no Maxima.  A sintaxe é:
</p>
<pre class="example">for <var>Variável</var> in <var>list</var> <var>end_tests</var> do <var>corpo</var>
</pre>
<p>Os elementos de <var>list</var> são quaisquer expressões que irão
sucessivamente ser atribuídas para a variável a cada iteração do
corpo.  O teste opcional <var>end_tests</var> pode ser usado para encerrar a execução da
declaração <code>do</code>; de outra forma o <code>do</code> terminará quando a lista for exaurida ou quando
um <code>return</code> for executado no corpo.  (De facto, a lista pode ser qualquer
expressão não at&ocirc;mica, e partes sucessivas são usadas.)
</p>
<pre class="example">(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>errcatch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1356"></a>
</dt>
<dd><p>Avalia <var>expr_1</var>, ..., <var>expr_n</var> uma por uma e
retorna <code>[<var>expr_n</var>]</code> (uma lista) se nenhum erro ocorrer.  Se um
erro ocorrer na avaliação de qualquer argumento, <code>errcatch</code>
evita que o erro se propague e
retorna a lista vazia <code>[]</code> sem avaliar quaisquer mais argumentos.
</p>
<p><code>errcatch</code>
é útil em ficheiros <code>batch</code> onde se suspeita que um erro possa estar ocorrendo o <code>errcatch</code>
terminará o <code>batch</code> se o erro não for detectado.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>error</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1357"></a>
</dt>
<dt><u>Variável de sistema:</u> <b>error</b>
<a name="IDX1358"></a>
</dt>
<dd><p>Avalia e imprime <var>expr_1</var>, ..., <var>expr_n</var>,
e então causa um retorno de erro para o nível mais alto do Maxima
ou para o mais próximo contendo <code>errcatch</code>.
</p>
<p>A variável <code>error</code> é escolhida para uma lista descrevendo o erro.
O primeiro elemento de <code>error</code> é uma sequência de caracteres de formato,
que junta todas as sequências de caracteres entre os argumentos <var>expr_1</var>, ..., <var>expr_n</var>,
e os elementos restantes são os valores de quaisquer argumentos que não são sequências de caracteres.
</p>
<p><code>errormsg()</code> formata e imprime <code>error</code>.
Isso efectivamente reimprime a mais recente mensagem de erro.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>errormsg</b><i> ()</i>
<a name="IDX1359"></a>
</dt>
<dd><p>Reimprime a mais recente mensagem de erro.
A variável <code>error</code> recebe a mensagem,
e <code>errormsg</code> formata e imprime essa mensagem.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>for</b>
<a name="IDX1360"></a>
</dt>
<dd><p>Usado em iterações.  Veja <code>do</code> para uma descrição das
facilidades de iteração do Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>go</b><i> (<var>tag</var>)</i>
<a name="IDX1361"></a>
</dt>
<dd><p>é usada dentro de um <code>block</code> para transferir o controle para a declaração
do bloco que for identificada com o argumento para <code>go</code>.  Para identificar uma
declaração, coloque antes dessa declaração um argumento at&ocirc;mico como outra declaração no
<code>block</code>.  Por exemplo:
</p>
<pre class="example">block ([x], x:1, loop, x+1, ..., go(loop), ...)
</pre>
<p>O argumento para <code>go</code> deve ser o nome de um identificardor aparecendo no mesmo
<code>block</code>.  Não se pode usar <code>go</code> para transferir para um identificador em um outro <code>block</code> que não seja
o próprio contendo o <code>go</code>.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>if</b>
<a name="IDX1362"></a>
</dt>
<dd><p>Representa avaliação condicional. Várias formas de expressões <code>if</code> são reconhecidas.
<code>if <var>cond_1</var> then <var>expr_1</var> else <var>expr_0</var></code>
avalia para <var>expr_1</var> se <var>cond_1</var> avaliar para <code>true</code>,
de outra forma a expressão avalia para <code>expr_0</code>.
</p>
<p><code>if <var>cond_1</var> then <var>expr_1</var> elseif <var>cond_2</var> then <var>expr_2</var> elseif ... else <var>expr_0</var></code>
avalia para <var>expr_k</var> se <var>cond_k</var> for <code>true</code> e todas as condições precedentes forem <code>false</code>.
Se nenhuma das condições forem <code>true</code>, a expressão avalia para <code>expr_0</code>.
</p>
<p>O comportamento <code>else false</code> é assumido se <code>else</code> for omitido.
Isso é, <code>if <var>cond_1</var> then <var>expr_1</var></code> é equivalente a
<code>if <var>cond_1</var> then <var>expr_1</var> else false</code>,
e <code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var></code>
é equivalente a
<code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var> else false</code>.
</p>
<p>As alternativas <var>expr_0</var>, ..., <var>expr_n</var> podem ser quaisquer expressões do Maxima,
incluíndo expressões <code>if</code> aninhadas ( if dentro de if).
As alternativas não são nem simplificadas nem avaliadas a menos que a correspondente condição seja <code>true</code>.
</p>
<p>As condições <var>cond_1</var>, ..., <var>cond_n</var> são expressões tais que <code>is(<var>cond_k</var>)</code> avaliem
para <code>true</code> ou para <code>false</code>;
de outra forma é um erro.
Entre outros elementos, condições podem compreender operadores lógicos e relacionais como segue.
</p>
<pre class="example">Operação             Símbolo      Tipo
 
menor que            &lt;           infixo relacional
menor que            &lt;=
  ou igual a                     infixo relacional
igualdade            =
  (sintática)                    infixo relacional
negação de =         #           infixo relacional
igualdade (valor)    equal       função relacional
negação de           notequal
  igualdade                      função relacional
maior que            &gt;=
  ou igual a                     infixo relacional
maior que            &gt;           infixo relacional
e                    and         infixo lógico
ou                   or          infixo lógico
não                  not         prefixo lógico
</pre>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>map</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1363"></a>
</dt>
<dd><p>Retorna uma expressão cujo operador principal
é o mesmo que o das expressões
<var>expr_1</var>, ..., <var>expr_n</var> mas cujas subpartes são os resultados da
aplicação de <var>f</var> nas correspondentes subpartes das expressões.  <var>f</var> é ainda
o nome de uma função de <em>n</em> argumentos
ou é uma forma <code>lambda</code> de <em>n</em> argumentos.
</p>
<p><code>maperror</code> - se <code>false</code> fará com que todas as funções mapeadas
(1) parem quando elas terminarem retornando a menor expi se não forem todas as
expi do mesmo comprimento e (2) aplique fn a [exp1, exp2,...]
se expi não forem todas do mesmo tipo de objecto.  Se <code>maperror</code> for <code>true</code>
então uma mensagem de erro será dada nas duas instâncias acima.
</p>
<p>Um dos usos dessa função é para mapear (<code>map</code>) uma função (e.g. <code>partfrac</code>)
sobre cada termo de uma expressão muito larga onde isso comumente não poderia
ser possível usar a função sobre a expressão inteira devido a uma
exaustão de espaço da lista de armazenamento no decorrer da computação.
</p>
<pre class="example">(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map(&quot;=&quot;,[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


</pre></dd></dl>

<dl>
<dt><u>Função:</u> <b>mapatom</b><i> (<var>expr</var>)</i>
<a name="IDX1364"></a>
</dt>
<dd><p>Retorna <code>true</code> se e somente se <var>expr</var> for tratada pelas rotinas de
mapeamento como um átomo.  &quot;Mapatoms&quot; são átomos, números
(incluíndo números racioanais), e variáveis subscritas.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>maperror</b>
<a name="IDX1365"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>maperror</code> é <code>false</code>, faz com que todas as funções mapeadas, por exemplo
</p>
<pre class="example">map (f, expr_1, expr_2, ...))
</pre>
<p>(1) parem quando elas terminarem
retornando a menor expi se não forem todas as expi do mesmo
comprimento e (2) aplique <code>f</code> a <code>[expr_1, expr_2, ...]</code> se <code>expr_i</code> não forem todas
do mesmo tipo de objecto.
</p>
<p>Se <code>maperror</code> for <code>true</code> então uma ,mensagem de erro
é mostrada nas duas instâncias acima.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>maplist</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1366"></a>
</dt>
<dd><p>Retorna uma lista de aplicações de <var>f</var>
em todas as partes das expressões <var>expr_1</var>, ..., <var>expr_n</var>.
<var>f</var> é o nome de uma função, ou uma expressão lambda.
</p>
<p><code>maplist</code> difere de <code>map (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</code>
que retorna uma expressão com o mesmo operador principal que <var>expr_i</var> tem
(excepto para simplificações  e o caso onde <code>map</code> faz um <code>apply</code>).
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>prederror</b>
<a name="IDX1367"></a>
</dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>prederror</code> for <code>true</code>, uma mensagem de erro é mostrada
sempre que o predicado de uma declaração <code>if</code> ou uma função <code>is</code> falha em
avaliar ou para <code>true</code> ou para  <code>false</code>.
</p>
<p>Se <code>false</code>, <code>unknown</code> é retornado
no lugar nesse caso.  O modo <code>prederror: false</code> não é suportado no
código traduzido;
todavia, <code>maybe</code> é suportado no código traduzido.
</p>
<p>Veja também <code>is</code> e <code>maybe</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>return</b><i> (valor)</i>
<a name="IDX1368"></a>
</dt>
<dd><p>Pode ser usada para sair explicitamente de um bloco, levando
seu argumento.  Veja <code>block</code> para mais informação.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>)</i>
<a name="IDX1369"></a>
</dt>
<dt><u>Função:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>, bottomup)</i>
<a name="IDX1370"></a>
</dt>
<dd><p>Recursivamente aplica <var>f</var> a <var>expr</var>, de cima
para baixo.  Isso é muito útil quando uma factoração completa é
desejada, por exemplo:
</p>
<pre class="example">(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
</pre>
<p>Note o caminho através do qual <code>scanmap</code> aplica a dada função <code>factor</code> para as
subexpressões constituintes de <var>expr</var>; se outra forma de <var>expr</var> é apresentada
para <code>scanmap</code> então o resultado pode ser diferente.  Dessa forma, <code>%o2</code> não é
recuperada quando <code>scanmap</code> é aplicada para a forma expandida de exp:
</p>
<pre class="example">(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
</pre>
<p>Aqui está um outro exemplo do caminho no qual <code>scanmap</code> aplica
recursivamente uma função dada para todas as subexpressões, incluindo expoentes:
</p>
<pre class="example">(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
</pre>
<p><code>scanmap (<var>f</var>, <var>expr</var>, bottomup)</code> aplica <var>f</var> a <var>expr</var> de
baixo para cima.  E.g., para <code>f</code> indefinida,
</p>
<pre class="example">scanmap(f,a*x+b) -&gt;
   f(a*x+b) -&gt; f(f(a*x)+f(b)) -&gt; f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -&gt; f(a)*f(x)+f(b)
    -&gt; f(f(a)*f(x))+f(b) -&gt;
     f(f(f(a)*f(x))+f(b))
</pre>
<p>Neste caso, obtém-se a mesma resposta pelos dois métodos.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>throw</b><i> (<var>expr</var>)</i>
<a name="IDX1371"></a>
</dt>
<dd><p>Avalia <var>expr</var> e descarta o valor retornado para o mais recente
<code>catch</code>.  <code>throw</code> é usada com <code>catch</code> como um mecanismo
de retorno não local.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>while</b>
<a name="IDX1372"></a>
</dt>
<dd><p>Veja <code>do</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>outermap</b><i> (<var>f</var>, <var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1373"></a>
</dt>
<dd><p>Aplica a função <var>f</var> para cada um dos elementos do produto externo
<var>a_1</var> vezes <var>a_2</var> ... vezes <var>a_n</var>.
</p>
<p><var>f</var> é o nome de uma função de <em>n</em> argumentos
ou uma expressão lambda de <em>n</em> argumentos.
Cada argumento <var>a_k</var> pode ser uma lista simples ou lista aninhada ( lista contendo listas como elementos ), ou uma matrz, ou qualquer outro tip de expressão.
</p>
<p>O valor de retorno de <code>outermap</code> é uma estrutura aninhada.
Tomemos <var>x</var> como sendo o valor de retorno.
Então <var>x</var> tem a mesma estrutura da primeira lista, lista aninhada, ou argumento matriz,
<code><var>x</var>[i_1]...[i_m]</code> tem a mesma estrutura que a segunda lista, lista aninhada, ou argumento matriz,
<code><var>x</var>[i_1]...[i_m][j_1]...[j_n]</code> tem a mesma estrutura que a terceira lista, lista aninhada, ou argumento matriz,
e assim por diante,
onde <var>m</var>, <var>n</var>, ... são os números dos índices requeridos para acessar os
elementos de cada argumento (um para uma lista, dois para uma matriz, um ou mais para uma lista aninhada).
Argumentos que não forem listas ou matrizes não afectam a estrutura do valor de retorno.
</p>
<p>Note que o efeito de <code>outermap</code> é diferente daquele de aplicar <var>f</var>
a cada um dos elementos do produto externo retornado por <code>cartesian_product</code>.
<code>outermap</code> preserva a estrutura dos argumentos no valor de retorno,
enquanto <code>cartesian_product</code> não reserva essa mesma estrutura.
</p>
<p><code>outermap</code> avalia seus argumentos.
</p>
<p>Veja também <code>map</code>, <code>maplist</code>, e <code>apply</code>.
</p>
<p>Exemplos:
Exemplos elementares de <code>outermap</code>.
Para mostrar a a combinação de argumentos mais claramente, <code>F</code> está indefinida à esquerda.
</p>
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap (&quot;+&quot;, [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
</pre>
<p>Uma explanação final do valor de retorno de <code>outermap</code>.
Os argumentos primeiro, segundo, e terceiro são matriz, lista, e matriz, respectivamente.
O valor de retorno é uma matriz.
Cada elementos daquela matriz é uma lista,
e cada elemento de cada lista é uma matriz.
</p>
<pre class="example">(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
</pre>
<p><code>outermap</code> preserves the structure of the arguments in the return value,
while <code>cartesian_product</code> does not.
</p>
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
(%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
</pre>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC162" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC165" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>Dezembro, 9 2014</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
