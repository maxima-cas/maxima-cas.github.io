<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Dezembro, 9 2014 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima 5.35.0: 4. Linha de Comandos</title>

<meta name="description" content="Manual do Maxima 5.35.0: 4. Linha de Comandos">
<meta name="keywords" content="Manual do Maxima 5.35.0: 4. Linha de Comandos">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Linha-de-Comandos"></a>
<a name="SEC9"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_3.html#SEC8" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC10" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_3.html#SEC4" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC12" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 4. Linha de Comandos </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC10">4.1 Introdução a Linha de Comandos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC11">4.2 Definições para Linha de Comandos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-Linha-de-Comandos"></a>
<a name="SEC10"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC9" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC12" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.1 Introdução a Linha de Comandos </h2>

<dl>
<dt><u>Operador:</u> <b>'</b>
<a name="IDX14"></a>
</dt>
<dd><p>O operador apóstrofo <code>'</code> evita avaliação.
</p>
<p>Aplicado a um símbolo,
o apóstrofo evita avaliação do símbolo.
</p>
<p>Aplicado a uma chamada de função,
o apóstrofo evita avaliação da chamada de função,
embora os argumentos da função sejam ainda avaliados (se a avaliação não for de outra forma evitada).
O resultado é a forma substantiva da chamada de função.
</p>
<p>Aplicada a uma espressão com parêntesis,
o apóstrofo evita avaliação de todos os símbolos e chamadas de função na expressão.
E.g., <code>'(f(x))</code> significa não avalie a expressão <code>f(x)</code>.
<code>'f(x)</code> (com apóstrofo aplicado a <code>f</code> em lugar de <code>f(x)</code>)
retorna a forma substantiva de <code>f</code> aplicada a <code>[x]</code>.
</p>
<p>O apóstrofo nao evita simplificação.
</p>
<p>Quando o sinalizador global <code>noundisp</code> for <code>true</code>,
substantivos são mostrados com um apóstrofo.
Esse comutador é sempre <code>true</code> quando mostrando definições de funções.
</p>
<p>Veja também operador apóstrofo-apóstrofo <code>''</code> e <code>nouns</code>.
</p>
<p>Exemplos:
</p>
<p>Aplicado a um símbolo,
o apóstrofo evita avaliação do símbolo.
</p>
<pre class="example">(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
</pre>
<p>Aplicado a uma chamada de função,
o apóstrofo evita avaliação da chamada de função.
O resultado é a forma substantiva da chamada de função.
</p>
<pre class="example">(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
</pre>
<p>Aplicado a uma expressão com parêntesis,
o apóstrofo evita avaliação de todos os símbolos e chamadas de função na expressão.
</p>
<pre class="example">(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
</pre>
<p>O apóstrofo não evita simplificação.
</p>
<pre class="example">(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
</pre>
</dd></dl>

<dl>
<dt><u>Operador:</u> <b>&quot;</b>
<a name="IDX15"></a>
</dt>
<dd><p>O operador apóstrofo-apóstrofo <code>''</code> (dois apóstrofost) modifica avaliação em expressões de entrada.
</p>
<p>Aplicado a uma expressão geral <var>expr</var>, apóstrofo-apóstrofo faz com que o valor de <var>expr</var>
seja substituído por <var>expr</var> na expressão de entrada.
</p>
<p>Aplicado ao operadro de uma expressão,
apóstrofo-apóstrofo modifica o operadro de um susbstantivo para um verbo (se esse operador não for já um verbo).
</p>
<p>O operador apóstrofo-apóstrofo é aplicado através do passador de entrada;
o apóstrofo-apóstrofo não é armazenado como parte de uma expressão de entrada passada.
O operador apóstrofo-apóstrofo é sempre aplicado tão rapidamente quanto for passado,
e não pode receber um terceiro apóstrofo.
Dessa forma faz com que ocorra avaliação quando essa avaliação for de outra forma suprimida,
da mesma forma que em definições de função, definições de expressãoes lambda, e expressões que recebem um apóstrofo simples <code>'</code>.
</p>
<p>Apóstrofo-apóstrofo é reconhecido por <code>batch</code> e <code>load</code>.
</p>
<p>Veja também o operador apóstrofo <code>'</code> e <code>nouns</code>.
</p>
<p>Exemplos:
</p>
<p>Aplicado a uma expressão geral <var>expr</var>, apóstrofo-apóstrofo fazem com que o valor de <var>expr</var>
seja substituido por <var>expr</var> na expressão de entrada.
</p>
<pre class="example">(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
</pre>
<p>Aplicado ao operador de uma expressão,
apóstrofo-apóstrofo muda o operadro de um substantivo para um verbo (se esse operadro não for já um verbo).
</p>
<pre class="example">(%i1) sin (1);
(%o1)                        sin(1)
(%i2) ''sin (1);
(%o2)                    0.8414709848079
(%i3) declare (foo, noun);
(%o3)                         done
(%i4) foo (x) := x - 1729;
(%o4)                 ''foo(x) := x - 1729
(%i5) foo (100);
(%o5)                       foo(100)
(%i6) ''foo (100);
(%o6)                        - 1629
</pre>
<p>O operador apóstrofo-apóstrofo é aplicado por meio de um passador de entrada;
operador-apóstrofo não é armazenado como parte da expressão de entrada.
</p>
<pre class="example">(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
</pre>
<p>Apóstrofo apóstrofo faz com que ocorra avaliação quando a avaliação tiver sido de outra forma suprimida,
da mesma forma que em definições de função, da mesma forma que em definições de função lambda expressions, E expressões que recebem o apóstrofo simples <code>'</code>.
</p>
<pre class="example">(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
</pre>
</dd></dl>

<hr size="6">
<a name="Defini_00e7_00f5es-para-Linha-de-Comandos"></a>
<a name="SEC11"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC10" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC12" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC12" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.2 Definições para Linha de Comandos </h2>

<dl>
<dt><u>Função:</u> <b>alias</b><i> (<var>new_name_1</var>, <var>old_name_1</var>, ..., <var>new_name_n</var>, <var>old_name_n</var>)</i>
<a name="IDX16"></a>
</dt>
<dd><p>provê um
nome alternativo para uma função (de utilizador ou de sistema), variável, array, etc.
Qualquer número de argumentos pode ser usado.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>debugmode</b>
<a name="IDX17"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando um erro do Maxima ocorre, Maxima iniciará o depurador se <code>debugmode</code> for <code>true</code>.
O utilizador pode informar comandos para examinar o histórico de chamadas, marcar pontos de parada, percorrer uma linha por vez
o código do Maxima, e assim por diante.  Veja <code>debugging</code> para uma lista de opções do depurador.
</p>
<p>Habilitando <code>debugmode</code> por meio da alteração de seu valor para <code>true</code>, não serão capturados erros do Lisp.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>ev</b><i> (<var>expr</var>, <var>arg_1</var>, ..., <var>arg_n</var>)</i>
<a name="IDX18"></a>
</dt>
<dd><p>Avalia a expressão <var>expr</var> no ambiente
especificado pelos argumentos <var>arg_1</var>, ..., <var>arg_n</var>.
Os argumentos são comutadores (sinalizadores Booleanos), atribuições, equações, e funções.
<code>ev</code> retorna o resultado (outra expressão) da avaliação.
</p>
<p>A avaliação é realizada em passos, como segue.
</p>
<ol>
<li>
Primeiro o ambiente é preparado examinando os argumentos que podem
ser quaisquer ou todos os seguintes.

<ul>
<li>
<code>simp</code> faz com que <var>expr</var> seja simplificado independentemente da posição do
comutador <code>simp</code> que inibe simplificação se <code>false</code>.
</li><li>
<code>noeval</code> suprime a fase de avaliação de <code>ev</code> (veja passo (4) adiante).
Isso é útil juntamente com outros comutadores e faz com que
<var>expr</var> seja simplificado novamente sem ser reavaliado.
</li><li>
<code>nouns</code> causa a avaliação de formas substantivas
(tipicamente funções não avaliadas tais como <code>'integrate</code> ou <code>'diff</code>)
em <var>expr</var>.
</li><li>
<code>expand</code> causa expansão.
</li><li>
<code>expand (<var>m</var>, <var>n</var>)</code> causa expansão, alterando os valores de <code>maxposex</code> e
<code>maxnegex</code> para <var>m</var> e <var>n</var> respectivamente.
</li><li>
<code>detout</code> faz com que qualquer matriz inversa calculada em <var>expr</var> tenha seu
determinante mantido fora da inversa ao invés de dividindo a
cada elemento.
</li><li>
<code>diff</code> faz com que todas as diferenciações indicadas em <var>expr</var> sejam executadas.
</li><li>
<code>derivlist (<var>x</var>, <var>y</var>, <var>z</var>, ...)</code> causa somente diferenciações referentes às
variáveis indicadas.
</li><li>
<code>float</code> faz com que números racionais não inteiros sejam convertidos para ponto 
flutuante.
</li><li>
<code>numer</code> faz com que algumas funções matemáticas (incluindo a exponenciação)
com argumentos sejam valiadas em ponto flutuante.  Isso faz com que
variávels em <var>expr</var> que tenham sido dados numervals (valores numéricos) sejam substituídas por
seus valores.  Isso também modifica o comutador <code>float</code> para activado.
</li><li>
<code>pred</code> faz com que predicados (expressões que podem ser avaliados em <code>true</code> ou <code>false</code>)
sejam avaliadas.
</li><li>
<code>eval</code> faz com que uma avaliação posterior de <var>expr</var> ocorra.  (Veja passo (5)
adiante.)
<code>eval</code> pode ocorrer múltiplas vezes.
Para cada instância de <code>eval</code>, a expressão é avaliada novamente.
</li><li>
<code>A</code> onde <code>A</code> é um átomo declarado seja um sinalizador de avaliação (veja <code>evflag</code>)
faz com que <code>A</code> seja associado a
<code>true</code> durante a avaliação de <var>expr</var>.
</li><li>
<code>V: expresão</code> (ou alternativamente <code>V=expressão</code>) faz com que <code>V</code> seja associado ao
valor de <code>expressão</code> durante a avaliação de <var>expr</var>.  Note que se <code>V</code> é uma
opção do Maxima, então <code>expression</code> é usada para seu valor durante a
avaliação de <var>expr</var>.  Se mais que um argumento para <code>ev</code> é desse tipo
então a associação termina em paralelo.  Se <code>V</code> é uma expressão não at&ocirc;mica
então a substituição, ao invés de uma associação, é executada.
</li><li>
<code>F</code> onde <code>F</code>, um nome de função, tenha sido declarado para ser uma função de avaliação (veja <code>evfun</code>)
faz com que <code>F</code>
seja aplicado a <var>expr</var>.
</li><li>
Qualquer outro nome de função (e.g., <code>sum</code>) causa a avaliação de ocorrências
desses nomes em <var>expr</var> mesmo que eles tenham sido verbos.
</li><li>
De forma adicional uma função ocorrendo em <var>expr</var> (digamos <code>F(x)</code>) pode ser definida
localmente para o propósito dessa avaliação de <var>expr</var> dando
<code>F(x) := expressão</code> como um argumento para <code>ev</code>.
</li><li>
Se um átomo não mensionado acima ou uma variável subscrita ou
expressão subscrita for dada como um argumento, isso é avaliado e
se o resultado for uma equação ou uma atribuição então a associação indicada
ou substituição é executada.  Se o resultado for uma lista então os
membros da lista serão tratados  como se eles fossem argumentos adicionais
dados para <code>ev</code>.  Isso permite que uma lista de equações seja dada (e.g. <code>[X=1, Y=A**2]</code>)
ou que seja dado uma lista de nomes de equações (e.g., <code>[%t1, %t2]</code> onde <code>%t1</code> e
<code>%t2</code> são equações) tais como aquelas listas retornadas por <code>solve</code>.
</li></ul>

<p>Os argumentos de <code>ev</code> podem ser dados em qualquer ordem com exceção de
substituições de equações que são manuseadas em sequência, da esquerda para a direita,
e funções de avaliação que são compostas, e.g., <code>ev (<var>expr</var>, ratsimp, realpart)</code> são
manuseadas como <code>realpart (ratsimp (<var>expr</var>))</code>.
</p>
<p>Os comutadores <code>simp</code>, <code>numer</code>, <code>float</code>, e <code>pred</code> podem também ser alterados localmente em um
bloco, ou globalmente no Maxima dessa forma eles irã
permanecer em efeito até serem resetados ao término da execução do bloco.
</p>
<p>Se <var>expr</var> for uma expressão racional canónica (CRE),
então a expressão retornada por <code>ev</code> é também uma CRE,
contanto que os comutadores <code>numer</code> e <code>float</code> não sejam ambos <code>true</code>.
</p>
</li><li>
Durante o passo (1), é feito uma lista  de variáveis não subscritas
aparecendo do lado esquerdo das equações nos argumentos ou nos
valores de alguns argumentos se o valor for uma equação.  As variáveis
(variáveis subscritas que não possuem funções array
associadas bem como variáveis não subscritas) na expressão <var>expr</var> são
substituídas por seus valores globais, excepto para esse aparecendo nessa 
lista.  Usualmente, <var>expr</var> é apenas um rótulo ou <code>%</code>
(como em <code>%i2</code> no exemplo adiante), então esse 
passo simplesmente repete a expressão nomeada pelo rótulo, de modo que <code>ev</code>
possa trabalhar sobre isso.

</li><li>
Se quaisquer substituições tiveem sido indicadas pelos argumentos, elas serão
realizadas agora.

</li><li>
A expressão resultante é então reavaliada (a menos que um dos
argumentos seja <code>noeval</code>) e simplificada conforme os argumentos.  Note que
qualquer chamada de função em <var>expr</var> será completada depois das variáveis
nela serem avalidas e que <code>ev(F(x))</code> dessa forma possa comportar-se como <code>F(ev(x))</code>.

</li><li>
Para cada instância de <code>eval</code> nos argumentos, os passos (3) e (4) são repetidos.
</li></ol>

<p>                     Exemplos
</p>
<pre class="example">(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
</pre>
<p>Uma sintaxe alternativa de alto nível tem sido provida por <code>ev</code>, por meio da qual
se pode apenas digitar seus argumentos, sem o <code>ev()</code>.  Isto é, se pode
escrever simplesmente
</p>
<pre class="example"><var>expr</var>, <var>arg_1</var>, ..., <var>arg_n</var>
</pre>
<p>Isso não é permitido como parte de
outra expressão, e.g., em funções, blocos, etc.
</p>
<p>Observe o processo de associação paralela no seguinte exemplo.
</p>
<pre class="example">(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x &gt; gamma (1/2);
                                   1
(%o9)                          x + - &gt; sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 &gt; 1.772453850905516
(%i11) %, pred;
(%o11)                               true
</pre>
</dd></dl>

<dl>
<dt><u>Propriedade:</u> <b>evflag</b>
<a name="IDX19"></a>
</dt>
<dd><p>Quando um símbolo <var>x</var> tem a propriedade <code>evflag</code>,
as expressões <code>ev(<var>expr</var>, <var>x</var>)</code> e <code><var>expr</var>, <var>x</var></code>
(na linha de comando interativa) são equivalentes a <code>ev(<var>expr</var>, <var>x</var> = true)</code>.
Isto é, <var>x</var> está associada a <code>true</code> enquanto <var>expr</var> for avaliada.
</p>
<p>A expressão <code>declare(<var>x</var>, evflag)</code>
fornece a propriedade <code>evflag</code> para a variável <var>x</var>.
</p>
<p>Os sinalizadores que possuem a propriedade <code>evflag</code> por padrão são os seguintes:
<code>algebraic</code>,
<code>cauchysum</code>,
<code>demoivre</code>,
<code>dotscrules</code>,
<code>%emode</code>,
<code>%enumer</code>,
<code>exponentialize</code>,
<code>exptisolate</code>,
<code>factorflag</code>,
<code>float</code>,
<code>halfangles</code>,
<code>infeval</code>,
<code>isolate_wrt_times</code>,
<code>keepfloat</code>,
<code>letrat</code>,
<code>listarith</code>,
<code>logabs</code>,
<code>logarc</code>,
<code>logexpand</code>,
<code>lognegint</code>,
<code>lognumer</code>,
<code>m1pbranch</code>,
<code>numer_pbranch</code>,
<code>programmode</code>,
<code>radexpand</code>,
<code>ratalgdenom</code>,
<code>ratfac</code>,
<code>ratmx</code>,
<code>ratsimpexpons</code>,
<code>simp</code>,
<code>simpsum</code>,
<code>sumexpand</code>, e
<code>trigexpand</code>.
</p>
<p>Exemplos:
</p>
<pre class="example">(%i1) sin (1/2);
                                 1
(%o1)                        sin(-)
                                 2
(%i2) sin (1/2), float;
(%o2)                   0.479425538604203
(%i3) sin (1/2), float=true;
(%o3)                   0.479425538604203
(%i4) simp : false;
(%o4)                         false
(%i5) 1 + 1;
(%o5)                         1 + 1
(%i6) 1 + 1, simp;
(%o6)                           2
(%i7) simp : true;
(%o7)                         true
(%i8) sum (1/k^2, k, 1, inf);
                            inf
                            ====
                            \     1
(%o8)                        &gt;    --
                            /      2
                            ====  k
                            k = 1
(%i9) sum (1/k^2, k, 1, inf), simpsum;
                                 2
                              %pi
(%o9)                         ----
                               6
(%i10) declare (aa, evflag);
(%o10)                        done
(%i11) if aa = true then SIM else NÃO;
(%o11)                         NÃO
(%i12) if aa = true then SIM else NÃO, aa;
(%o12)                         SIM
</pre>
</dd></dl>

<dl>
<dt><u>Propriedade:</u> <b>evfun</b>
<a name="IDX20"></a>
</dt>
<dd><p>Quando uma função <var>F</var> tem a propriedade <code>evfun</code>,
as expressões <code>ev(<var>expr</var>, <var>F</var>)</code> e <code><var>expr</var>, <var>F</var></code>
(na linha de comando interativa)
são equivalentes a <code><var>F</var>(ev(<var>expr</var>))</code>.
</p>
<p>Se duas ou mais funções <var>F</var>, <var>G</var>, etc., que possuem a propriedade <code>evfun</code> forem especificadas,
as funções serão aplicadas na ordem em que forem especificadas.
</p>
<p>A expressão <code>declare(<var>F</var>, evfun)</code>
fornece a propriedade <code>evfun</code> para a função <var>F</var>.
</p>
<p>As funções que possuem a propriedade <code>evfun</code> por padrão são as seguintes:
<code>bfloat</code>,
<code>factor</code>,
<code>fullratsimp</code>,
<code>logcontract</code>,
<code>polarform</code>,
<code>radcan</code>,
<code>ratexpand</code>,
<code>ratsimp</code>,
<code>rectform</code>,
<code>rootscontract</code>,
<code>trigexpand</code>, e
<code>trigreduce</code>.
</p>
<p>Exemplos:
</p> 
<pre class="example">(%i1) x^3 - 1;
                              3
(%o1)                        x  - 1
(%i2) x^3 - 1, factor;
                                2
(%o2)                 (x - 1) (x  + x + 1)
(%i3) factor (x^3 - 1);
                                2
(%o3)                 (x - 1) (x  + x + 1)
(%i4) cos(4 * x) / sin(x)^4;
                            cos(4 x)
(%o4)                       --------
                               4
                            sin (x)
(%i5) cos(4 * x) / sin(x)^4, trigexpand;
                 4           2       2         4
              sin (x) - 6 cos (x) sin (x) + cos (x)
(%o5)         -------------------------------------
                                4
                             sin (x)
(%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                           2         4
                      6 cos (x)   cos (x)
(%o6)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                           2         4
                      6 cos (x)   cos (x)
(%o7)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i8) declare ([F, G], evfun);
(%o8)                         done
(%i9) (aa : bb, bb : cc, cc : dd);
(%o9)                          dd
(%i10) aa;
(%o10)                         bb
(%i11) aa, F;
(%o11)                        F(cc)
(%i12) F (aa);
(%o12)                        F(bb)
(%i13) F (ev (aa));
(%o13)                        F(cc)
(%i14) aa, F, G;
(%o14)                      G(F(cc))
(%i15) G (F (ev (aa)));
(%o15)                      G(F(cc))
</pre>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>infeval</b>
<a name="IDX21"></a>
</dt>
<dd><p>Habilita o modo &quot;avaliação infinita&quot;.  <code>ev</code> repetidamente avalia
uma expressão até que ela permaneça invariante.  Para prevenir uma
variável, digamos <code>X</code>, seja demoradamente avaliada nesso modo, simplesmente
inclua <code>X='X</code> como um argumento para <code>ev</code>.  Certamente expressões tais como
<code>ev (X, X=X+1, infeval)</code> irão gerar um ciclo infinito.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>kill</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX22"></a>
</dt>
<dt><u>Função:</u> <b>kill</b><i> (labels)</i>
<a name="IDX23"></a>
</dt>
<dt><u>Função:</u> <b>kill</b><i> (inlabels, outlabels, linelabels)</i>
<a name="IDX24"></a>
</dt>
<dt><u>Função:</u> <b>kill</b><i> (<var>n</var>)</i>
<a name="IDX25"></a>
</dt>
<dt><u>Função:</u> <b>kill</b><i> ([<var>m</var>, <var>n</var>])</i>
<a name="IDX26"></a>
</dt>
<dt><u>Função:</u> <b>kill</b><i> (values, functions, arrays, ...)</i>
<a name="IDX27"></a>
</dt>
<dt><u>Função:</u> <b>kill</b><i> (all)</i>
<a name="IDX28"></a>
</dt>
<dt><u>Função:</u> <b>kill</b><i> (allbut (<var>a_1</var>, ..., <var>a_n</var>))</i>
<a name="IDX29"></a>
</dt>
<dd><p>Remove todas as associações (valor, funções, array, ou regra) dos argumentos
<var>a_1</var>, ..., <var>a_n</var>.
Um argumento <var>a_k</var> pode ser um símbolo ou um elemento de array simples.
Quando <var>a_k</var> for um elemento de array simples, <code>kill</code> remove a associação daquele elemento
sem afectar qualquer outro elemento do array.
</p>
<p>Muitos argumentos especiais são reconhecidos.  
Diferentes famílias de argumentos 
podem ser combinadas, e.g., <code>kill (inlabels, functions, allbut (foo, bar))</code>
</p>
<p>todos os rótulos de entrada, de saída, e de expressões intermédias criados até então.
<code>kill (inlabels)</code> libera somente rótudos de entrada 
que começam com o valor corrente de <code>inchar</code>.
De forma semelhante,
<code>kill (outlabels)</code> libera somente rótulos de saída
que começam com o valor corrente de <code>outchar</code>,
e <code>kill (linelabels)</code> libera somente rótulos de expressões intermédias
que começam com o valor corrente de <code>linechar</code>.
</p>
<p><code>kill (<var>n</var>)</code>, onde <var>n</var> é um inteiro,
libera os <var>n</var> mais recentes rótulos de entrada e saída.
</p>
<p><code>kill ([<var>m</var>, <var>n</var>])</code> libera rótulos de entrada e saída de <var>m</var> até <var>n</var>.
</p>
<p><code>kill (<var>infolist</var>)</code>, onde <var>infolist</var> é um item em <code>infolists</code>
(tais como <code>values</code>, <code>functions</code>, ou <code>arrays</code>)
libera todos os ítens em <var>infolist</var>.
Veja também <code>infolists</code>.
</p>
<p><code>kill (all)</code> liberar todos os ítens em todas as infolists.
<code>kill (all)</code> não retorna variáveis globais para seus valores padrões;
Veja <code>reset</code> sobre esse ponto.
</p>
<p><code>kill (allbut (<var>a_1</var>, ..., <var>a_n</var>))</code>
remove a associação de todos os itens sobre todas as infolistas excepto para <var>a_1</var>, ..., <var>a_n</var>.
<code>kill (allbut (<var>infolist</var>))</code> libera todos os ítens excepto para si próprio em <var>infolist</var>,
onde <var>infolist</var> é <code>values</code>, <code>functions</code>, <code>arrays</code>, etc.
</p>
<p>A memória usada por uma propriedade de associação não será liberada até que todos os símbolos
sejam liberados disso.
Em particular, para liberar a memória usada pelo valor de um símbolo,
deve-se liberar o rótulo de saída que mosta o valor associado, bem como liberando o próprio símbolo.
</p>
<p><code>kill</code> coloca um apóstro em seus argumentos (não os avalia).
O operador apóstrofo-apóstrofo, <code>''</code>, faz com que ocorra avaliação.
</p>
<p><code>kill (<var>símbolo</var>)</code> libera todas as propriedades de <var>símbolo</var>.
Em oposição, <code>remvalue</code>, <code>remfunction</code>, <code>remarray</code>, e <code>remrule</code>
liberam uma propriedade específica.
</p>
<p><code>kill</code> sempre retorna <code>done</code>, igualmente se um argumento não tem associações.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>labels</b><i> (<var>símbolo</var>)</i>
<a name="IDX30"></a>
</dt>
<dt><u>Variável de sistema:</u> <b>labels</b>
<a name="IDX31"></a>
</dt>
<dd><p>Retorna a lista de rótulos de entradas, de saída, de expressões intermédias que começam com <var>símbolo</var>.
Tipicamente <var>símbolo</var> é o valor de <code>inchar</code>, <code>outchar</code>, ou <code>linechar</code>.
O caracter rótulo pode ser dado com ou sem o sinal de porcentagem,
então, por exemplo, <code>i</code> e <code>%i</code> retornam o mesmo resultado.
</p>
<p>Se nenhum rótulo começa com <var>símbolo</var>, <code>labels</code> retorna uma lista vazia.
</p>
<p>A função <code>labels</code> não avalia seu argumento.
O operador apóstrofo-apóstrofo <code>''</code> faz com que ocorra avaliação.
Por exemplo,
<code>labels (''inchar)</code> retorna os rótulos de entrada que começam com o caractere corrente do rótulo de entrada.
</p>
<p>A variável <code>labels</code> é uma lista de rótulos de entrada, saída, e de expressões intermédias,
incluindo todos os rótulos anteriores se <code>inchar</code>, <code>outchar</code>, ou <code>linechar</code> que tiverem sido redefinidos.
</p>
<p>Por padrão, Maxima mostra o resultado de cada expressão de entrada do utilizador,
dando ao resultado um rótulo de saída.
A exibição da saída é suprimida pelo encerramento da entrada com <code>$</code> (sinal de dolar)
em lugar de <code>;</code> (ponto e vírgula).
Um rótulo de saída é construido e associado ao resultado, mas não é mostrado, 
e o rótulo pode ser referenciado da mesma forma que rótulos de saída mostrados.
Veja também <code>%</code>, <code>%%</code>, e <code>%th</code>.
</p>
<p>Rótulos de expressões intermédias podem ser gerados por algumas funções.
O sinalizador <code>programmode</code> controla se <code>solve</code> e algumas outras funções
geram rótulos de expressões intermédias em lugar de retornar uma lista de expressões.
Algumas outras funções, tais como <code>ldisplay</code>, sempre geram rótulos de expressões intermédias.
</p>
<p>Veja também <code>inchar</code>, <code>outchar</code>, <code>linechar</code>, e <code>infolists</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de sistema:</u> <b>linenum</b>
<a name="IDX32"></a>
</dt>
<dd><p>Retorna o número da linha do par corrente de expressões de entrada e saída.
</p>
</dd></dl>

<dl>
<dt><u>Variável de sistema:</u> <b>myoptions</b>
<a name="IDX33"></a>
</dt>
<dd><p>Valor por omissão: <code>[]</code>
</p>
<p><code>myoptions</code> é a lista de todas as opções alguma vez alteradas pelo utilizador,
tenha ou não ele retornado a alteração para o seu valor padrão.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>nolabels</b>
<a name="IDX34"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>

<p>Quando <code>nolabels</code> for <code>true</code>,
rótulos de entrada e saída
(<code>%i</code> e <code>%o</code>, respectivamente)
são mostrados,
mas os rótulos não são associados aos resultados,
e os rótulos não são anexados ao final da lista <code>labels</code>.
Uma vez que rótulos não são associados aos resultados,
a reciclagem pode recuperar a memória tomada pelos resultados.
</p>
<p>De outra forma rótulos de entrada e saída são associados aos resultados,
e os rótulos são anexados ao final da lista <code>labels</code>.
</p>
<p>Veja também <code>batch</code>, <code>batchload</code>, e <code>labels</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>optionset</b>
<a name="IDX35"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>optionset</code> for <code>true</code>, Maxima mostrará uma
mensagem sempre que uma opção do Maxima for alterada.  Isso é útil se o
utilizador está incerto sobre a ortografia de alguma opção e quer ter certeza
que a variável por ele atribuído um valor foi realmente uma variável de opção.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>playback</b><i> ()</i>
<a name="IDX36"></a>
</dt>
<dt><u>Função:</u> <b>playback</b><i> (<var>n</var>)</i>
<a name="IDX37"></a>
</dt>
<dt><u>Função:</u> <b>playback</b><i> ([<var>m</var>, <var>n</var>])</i>
<a name="IDX38"></a>
</dt>
<dt><u>Função:</u> <b>playback</b><i> ([<var>m</var>])</i>
<a name="IDX39"></a>
</dt>
<dt><u>Função:</u> <b>playback</b><i> (input)</i>
<a name="IDX40"></a>
</dt>
<dt><u>Função:</u> <b>playback</b><i> (slow)</i>
<a name="IDX41"></a>
</dt>
<dt><u>Função:</u> <b>playback</b><i> (time)</i>
<a name="IDX42"></a>
</dt>
<dt><u>Função:</u> <b>playback</b><i> (grind)</i>
<a name="IDX43"></a>
</dt>
<dd><p>Mostra expressões de entrada, de saída, e expressões intermédias,
sem refazer os cálculos.
<code>playback</code> somente mostra as expressões associadas a rótulos;
qualquer outra saída (tais como textos impressos por <code>print</code> ou <code>describe</code>, ou messagens de erro)
não é mostrada.
Veja também <code>labels</code>.
</p>
<p><code>playback</code> não avalia seus argumentos.
O operador apóstrofo-apóstrofo, <code>''</code>, sobrepõe-se às aspas.
<code>playback</code> sempre retorna <code>done</code>.
</p>
<p><code>playback ()</code> (sem argumentos) mostra todas as entradas, saídas e expressões intermédias
geradas até então.
Uma expressão de saída é mostrada mesmo se for suprimida pelo terminador <code>$</code>
quando ela tiver sido originalmente calculada.
</p>
<p><code>playback (<var>n</var>)</code> mostra as mais recentes <var>n</var> expressões.
Cada entrada, saída e expressão intermédia
conta como um.
</p>
<p><code>playback ([<var>m</var>, <var>n</var>])</code> mostra entradas, saídas e expressões intermédias
com os números de <var>m</var> até <var>n</var>, inclusive.
</p>
<p><code>playback ([<var>m</var>])</code> é equivalente a <code>playback ([<var>m</var>, <var>m</var>])</code>;
isso usualmente imprime um par de expressões de entrada e saída.
</p>
<p><code>playback (input)</code> mostra todas as expressões de entrada geradas até então.
</p>
<p><code>playback (slow)</code> insere pausas entre expressões
e espera que o utilizador pressione <code>enter</code>.
Esse comportamento é similar a <code>demo</code>.
<code>playback (slow)</code> é útil juntamente com <code>save</code> ou <code>stringout</code>
quando criamos um ficheiro secundário de armazenagem com a finalidade de capturar expressões úteis.
</p>
<p><code>playback (time)</code> mostra o tempo de computação de cada expressão.
</p>
<p><code>playback (grind)</code> mostra expressões de entrada
no mesmo formato da função <code>grind</code>.
Expressões de saída não são afectadas pela opção <code>grind</code>.
Veja <code>grind</code>.
</p>
<p>Argumentos podem ser combinados, e.g., 
<code>playback ([5, 10], grind, time, slow)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>printprops</b><i> (<var>a</var>, <var>i</var>)</i>
<a name="IDX44"></a>
</dt>
<dt><u>Função:</u> <b>printprops</b><i> ([<var>a_1</var>, ..., <var>a_n</var>], <var>i</var>)</i>
<a name="IDX45"></a>
</dt>
<dt><u>Função:</u> <b>printprops</b><i> (all, <var>i</var>)</i>
<a name="IDX46"></a>
</dt>
<dd><p>Mostra a propriedade como o indicador <var>i</var>
associada com o átomo <var>a</var>.  <var>a</var> pode também ser uma lista de átomos ou o átomo
<code>all</code> nesse caso todos os átomos com a propriedade dada serão
usados.  Por exemplo, <code>printprops ([f, g], atvalue)</code>.  <code>printprops</code> é para
propriedades que não podem  ser mostradas de outra forma, i.e. para
<code>atvalue</code>, <code>atomgrad</code>, <code>gradef</code>, e <code>matchdeclare</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>prompt</b>
<a name="IDX47"></a>
</dt>
<dd><p>Valor por omissão: <code>_</code>
</p>
<p><code>prompt</code> é o símbolo de linha de comando da função <code>demo</code>,
modo <code>playback (slow)</code>, e da interrupção de ciclos do Maxima (como invocado por <code>break</code>).
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>quit</b><i> ()</i>
<a name="IDX48"></a>
</dt>
<dd><p>Encerra a sessão do Maxima.
Note que a função pode ser invocada como <code>quit();</code> ou <code>quit()$</code>,
não por sí mesma <code>quit</code>.
</p>
<p>Para parar um cálculo muito longo,
digite <code>control-C</code>.
A ação padrão é retornar à linha de comando do Maxima.
Se <code>*debugger-hook*</code> é <code>nil</code>,
<code>control-C</code> abre o depurador Lisp.
Veja também <code>debugging</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>remfunction</b><i> (<var>f_1</var>, ..., <var>f_n</var>)</i>
<a name="IDX49"></a>
</dt>
<dt><u>Função:</u> <b>remfunction</b><i> (all)</i>
<a name="IDX50"></a>
</dt>
<dd><p>Desassocia as definições de função dos síbolos <var>f_1</var>, ..., <var>f_n</var>.
Os argumentos podem ser os nomes de funções comuns (criadas por meio de <code>:=</code> ou <code>define</code>)
ou funções macro (criadas por meio de <code>::=</code>).
</p>
<p><code>remfunction (all)</code> desassocia todas as definições de funcção.
</p>
<p><code>remfunction</code> coloca um ap'ostrofo em seus argumentos (não os avalia).
</p>
<p><code>remfunction</code> retorna uma lista de símbolos para a qual a definição de função foi desassociada.
<code>false</code> é retornado em lugar de qualquer símbolo para o qual não exista definição de função.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>reset</b><i> ()</i>
<a name="IDX51"></a>
</dt>
<dd><p>Retorna muitas variáveis globais e opções, e algumas outras variáveis, para seus valores padrões.
</p>
<p><code>reset</code> processa as variáveis na lista Lisp <code>*variable-initial-values*</code>.
A macro Lisp <code>defmvar</code> coloca variáveis nessa lista (entre outras ações).
Muitas, mas não todas, variáveis globais e opções são definidas por <code>defmvar</code>,
 e algumas variáveis definidas por <code>defmvar</code> não são variáveis globais ou variáveis de opção.
</p>
</dd></dl>

<dl>
<dt><u>Variável de opção:</u> <b>showtime</b>
<a name="IDX52"></a>
</dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>showtime</code> for <code>true</code>, o tempo de computação e o tempo decorrido são
impressos na tela com cada expressão de saída.
</p>
<p>O tempo de cálculo é sempre gravado,
então <code>time</code> e <code>playback</code> podem mostrar o tempo de cálculo
mesmo quando <code>showtime</code> for <code>false</code>.
</p>
<p>Veja também <code>timer</code>.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>sstatus</b><i> (<var>recurso</var>, <var>pacote</var>)</i>
<a name="IDX53"></a>
</dt>
<dd><p>Altera o status de <var>recurso</var> em <var>pacote</var>.
Após <code>sstatus (<var>recurso</var>, <var>pacote</var>)</code> ser executado,
<code>status (<var>recurso</var>, <var>pacote</var>)</code> retorna <code>true</code>.
Isso pode ser útil para quem escreve pacotes, para
manter um registro de quais recursos os pacotes usam.
</p>
</dd></dl>

<dl>
<dt><u>Função:</u> <b>to_lisp</b><i> ()</i>
<a name="IDX54"></a>
</dt>
<dd><p>Insere o sistema Lisp dentro do Maxima.  <code>(to-maxima)</code> retorna para o Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Variável de sistema:</u> <b>values</b>
<a name="IDX55"></a>
</dt>
<dd><p>Valor inicial: <code>[]</code>
</p>
<p><code>values</code> é uma lista de todas as varáveis de utilizador associadas (não opções Maxima ou comutadores).
A lista compreende símbolos associados por <code>:</code> , <code>::</code>, ou <code>:=</code>.
</p>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC12" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC271" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>Dezembro, 9 2014</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
