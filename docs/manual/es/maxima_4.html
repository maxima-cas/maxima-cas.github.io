<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on diciembre, 30 2014 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.35.1: 4. Línea de comandos</title>

<meta name="description" content="Manual de Maxima 5.35.1: 4. Línea de comandos">
<meta name="keywords" content="Manual de Maxima 5.35.1: 4. Línea de comandos">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="L_00ednea-de-comandos"></a>
<a name="SEC7"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_3.html#SEC6" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC8" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_3.html#SEC4" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 4. Línea de comandos </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC8">4.1 Introducción a la línea de comandos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC16">4.2 Funciones y variables para la línea de comandos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC17">4.3 Funciones y variables para la impresión</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>










<hr size="6">
<a name="Introducci_00f3n-a-la-l_00ednea-de-comandos"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC7" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC16" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC7" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC7" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC8"></a>
<h2 class="section"> 4.1 Introducción a la línea de comandos </h2>


<a name="SEC9"></a>
<h3 class="subheading"> Consola </h3>

<p>Existen distintos interfaces para Maxima, tales como wxMaxima, Xmaxima, Imaxima
y la consola o terminal de texto.
</p>
<p>La consola trabaja en modo texto, al tiempo que para introducir instrucciones
con ayuda de un menú y obtener resultados en modo gráfico es necesario instalar
otros interfaces.
</p>
<p>A lo largo de este manual se utilizará la consola, la cual está disponible en
cualquiera de los sistemas operativos en los que trabaja Maxima. El usuario puede
introducir todas las funciones de Maxima desde la consola; en el modo texto, los
resultados se devolverán normalmente en un formato ASCII bidimensional, mientras
que los gráficos necesitan de un programa adicional tal como Gnuplot.
</p>
<a name="SEC10"></a>
<h3 class="subheading"> Entrada, Evaluación, Simplificación y Salida </h3>

<p>Desde que el usuario introduce una solicitud de cálculo hasta que obtiene el
resultado en la consola, se desarrolla un proceso que consta de cuatro fases:
</p>
<ol>
<li>
Bien sea desde un teclado o desde un fichero se lee una expresión que el
analizador sintáctico se encargará de transformar en una cierta representación
interna. En esta primera fase, se utilizan principalmente operadores tales
como &quot;+&quot;, &quot;/&quot; o &quot;do&quot;.

</li><li>
La expresión leída por el analizador sintáctico es evaluada
durante la segunda fase. Las variables se substituyen por sus valores y se
ejecutan funciones tales como la derivación o la integración. El resultado 
de esta fase es una expresión evaluada.

</li><li>
La expresión evaluada de la fase anterior se simplifica en esta tercera fase,
en la que una expresión tal como <code>a+a</code> se reduce a <code>2*a</code>, o
<code>sin(%pi/2)</code> se simplifica a <code>1</code>.

</li><li>
Tras la tercera fase se dispone de una expresión que ha sido evaluada y
posteriormente simplificada. Ya en la cuarta y última fase, se prepara
el resultado para ser mostrado a través de la consola.
</li></ol>

<p>El usuario puede tomar el control en cualquiera de las cuatro fases recién
descritas. En diferentes capítulos de este manual se detallan estas posibilidades,
pero en éste se describen aquellas instrucciones relacionadas con las fases
primera y cuarta, relacionadas con la entrada y salida a través de la consola.
Los capítulos sobre Evaluación y Simplificación tratan
de las otras dos fases intermedias.
</p>
<a name="SEC11"></a>
<h3 class="subheading"> Marcas </h3>

<p>Maxima almacena todas las entradas con la marca <code>%i</code> seguida de un
número entero en orden creciente, así como las salidas o resultados con la
marca <code>%o</code> también seguida de un número de orden. Además,
ciertas funciones utilizan la marca intermedia <code>%t</code>. Otras variables
del sistema almacenan el último resultado devuelto por Maxima o la
última entrada efectuada por el usuario. Los siguientes símbolos
indican variables y funciones para la gestión de las marcas:
</p>
<pre class="verbatim">   __          _        
   %           %%           %th
   inchar      linechar     outchar
   linenum     nolabels
</pre>
<a name="SEC12"></a>
<h3 class="subheading"> Listas informativas </h3>

<p>Maxima gestiona listas informativas, cuyos nombres se guardan en la variable
del sistema <code>infolists</code>. En el presente capítulo se
describen las listas <code>labels</code>, <code>values</code> y <code>myoptions</code>.
Los siguientes símbolos indican variables y funciones
relacionadas con las listas informativas y variables opcionales.
</p>
<pre class="verbatim">   infolists     labels        values 
   myoptions     optionset
</pre>
<p>Otras listas informativas, que se describirán en otros capítulos,
son:
</p>
<pre class="verbatim">   functions      arrays         macros
   rules          aliases        dependencies 
   gradefs        props          let_rule_packages
   structures     namespaces  
</pre>
<a name="SEC13"></a>
<h3 class="subheading"> Borrado y reiniciación </h3>

<p>A fin de establecer el contexto en el que trabaje Maxima, en el que
no haya variables o funciones definidas, o en el que se eliminen
hipótesis, propiedades o definiciones concretas, se dispone de las
siguientes funciones:
</p>
<pre class="verbatim">   kill     reset     reset_verbosely
</pre>
<a name="SEC14"></a>
<h3 class="subheading"> Otras instrucciones </h3>

<p>Se puede acceder a la documentación con los símbolos
<code>?</code> y <code>??</code>. En caso de que se utilice <code>?</code> a modo
de prefijo de un símbolo, éste se interpretará como
símbolo de Lisp. Hay instrucciones para terminar una sesión de 
Maxima o para cambiar a una sesión de Lisp. También es posible conocer el tiempo
que ha necesitado Maxima para realizar un cálculo. Para este tipo de cuestiones,
Maxima dispone de las siguientes instrucciones:
</p>
<pre class="verbatim">   ?            ??
   playback     prompt     showtime
   quit         to_lisp
</pre>
<p>Las funciones <code>read</code> und <code>readonly</code> imprimen texto en la consola y
leen la información introducida por el usuario.
</p>
<a name="SEC15"></a>
<h3 class="subheading"> Salida por consola </h3>

<p>Antes de mostrar un resultado, se transforma su representación interna 
a otra externa. Por ejemplo, la representación interna de <code>sqrt(x)</code>
es <code>x^(1/2)</code>, y ambos formatos pueden ser devueltos por Maxima en
función del valor que guarde la variable opcional <code>sqrtdispflag</code>.
</p>
<p>Los siguientes símbolos y variables opcionales controlan
la salida de resultados por consola:
</p>
<pre class="verbatim">   %edispflag         absboxchar       display2d
   display_format_internal             exptdispflag
   expt               nexpt            ibase
   linel              lispdisp         negsumdispflag
   obase              pfeformat        powerdisp
   sqrtdispflag       stardisp         ttyoff
</pre>
<p>Con las siguientes funciones es posible formatear los resultados:
</p>
<pre class="verbatim">   disp               display          dispterms
   grind              ldisp            ldisplay
   print
</pre>























<hr size="6">
<a name="Funciones-y-variables-para-la-l_00ednea-de-comandos"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC8" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC7" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC7" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC16"></a>
<h2 class="section"> 4.2 Funciones y variables para la línea de comandos </h2>


<dl>
<dt><u>Variable del sistema:</u> <b>__</b>
<a name="IDX13"></a>
</dt>
<dd><p><code>__</code> es la expresión de entrada que está siendo actualmente evaluada.
Esto es, mientras se está evaluando una expresión de entrada, 
<code>__</code> es igual a <var>expr</var>.
</p>
<p>A <code>__</code> se le asigna la expresión de entrada antes de que ésta sea 
simplificada o evaluada. Sin embargo, el valor de <code>__</code> es simplificado,
pero no evaluado, cuando su valor es mostrado en el terminal.
</p>
<p>La variable <code>__</code> es reconocida por  <code>batch</code> y por <code>load</code>.
Cuando un fichero es procesado por <code>batch</code>, la variable <code>__</code>
tiene el mismo significado que en el modo interactivo.
Cuando un fichero es procesado por <code>load</code>, a la variable <code>__</code>
se le asigna la última expresión introducida, bien desde el modo
interactivo, bien en un fichero por lotes; en ningún caso se le asigna 
a <code>__</code> una expresión de entrada del fichero que está siendo procesado.
En particular, si <code>load (<var>filename</var>)</code> es ejecutado desde el modo
interactivo, entonces <code>__</code> almacena la expresión <code>load (<var>filename</var>)</code>
mientras el fichero está siendo procesado.
</p>
<p>Véanse también <code>_</code> y <code>%</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) print (&quot;I was called as&quot;, __);
I was called as print(I was called as, __) 
(%o1)              print(I was called as, __)
(%i2) foo (__);
(%o2)                     foo(foo(__))
(%i3) g (x) := (print (&quot;Current input expression =&quot;, __), 0);
(%o3) g(x) := (print(&quot;Current input expression =&quot;, __), 0)
(%i4) [aa : 1, bb : 2, cc : 3];
(%o4)                       [1, 2, 3]
(%i5) (aa + bb + cc)/(dd + ee + g(x));
                            cc + bb + aa
Current input expression = -------------- 
                           g(x) + ee + dd
                                6
(%o5)                        -------
                             ee + dd
</pre>
</dd></dl>





<dl>
<dt><u>Variable del sistema:</u> <b>_</b>
<a name="IDX14"></a>
</dt>
<dd><p>El símbolo <code>_</code> representa la última expresión de entrada (esto es, <code>%i1</code>, <code>%i2</code>, <code>%i3</code>, ...).
</p>
<p>Al símbolo <code>_</code> se le asigna la expresión de entrada antes de que ésta sea simplificada o evaluada. Sin embargo, el valor de <code>_</code> se simplifica (pero no se evalúa) cuando se muestra en el terminal.
</p>
<p>La variable <code>_</code> es reconocida por  <code>batch</code> y por <code>load</code>.
Cuando un fichero es procesado por <code>batch</code>, la variable <code>_</code>
tiene el mismo significado que en el modo interactivo.
Cuando un fichero es procesado por <code>load</code>, a la variable <code>_</code>
se le asigna la última expresión introducida, bien desde el modo
interactivo, bien en un fichero por lotes; en ningún caso se le asigna 
a <code>_</code> una expresión de entrada del fichero que está siendo procesado.
</p>
<p>Véanse también <code>__</code> y <code>%</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) 13 + 29;
(%o1)                          42
(%i2) :lisp $_
((MPLUS) 13 29)
(%i2) _;
(%o2)                          42
(%i3) sin (%pi/2);
(%o3)                           1
(%i4) :lisp $_
((%SIN) ((MQUOTIENT) $%PI 2))
(%i4) _;
(%o4)                           1
(%i5) a: 13$
(%i6) b: 29$
(%i7) a + b;
(%o7)                          42
(%i8) :lisp $_
((MPLUS) $A $B)
(%i8) _;
(%o8)                         b + a
(%i9) a + b;
(%o9)                          42
(%i10) ev (_);
(%o10)                         42
</pre>
</dd></dl>



<dl>
<dt><u>Variable del sistema:</u> <b>%</b>
<a name="IDX15"></a>
</dt>
<dd><p>El símbolo <code>%</code> representa la expresión de salida (esto es, <code>%o1</code>, <code>%o2</code>, <code>%o3</code>, ...)
más reciente calculada por Maxima, independientemente de que la haya mostrado o no.
</p>
<p>La variable <code>%</code> es reconocida por  <code>batch</code> y por <code>load</code>.
Cuando un fichero es procesado por <code>batch</code>, la variable <code>%</code>
tiene el mismo significado que en el modo interactivo.
Cuando un fichero es procesado por <code>load</code>, a la variable <code>%</code>
se le asigna la última expresión introducida, bien desde el modo
interactivo, bien en un fichero por lotes; en ningún caso se le asigna 
a <code>%</code> una expresión de entrada del fichero que está siendo procesado.
</p>
<p>Véanse también <code>_</code>, <code>%%</code> y <code>%th</code>.
</p>
</dd></dl>




<dl>
<dt><u>Variable del sistema:</u> <b>%%</b>
<a name="IDX16"></a>
</dt>
<dd><p>En una sentencia compuesta, como <code>block</code>, <code>lambda</code> o 
<code>(<var>s_1</var>, ..., <var>s_n</var>)</code>, <code>%%</code> es el valor de la sentencia previa.
</p>
<p>La variable <code>%%</code> no estÃ¡ definida cuando se utiliza en la primera sentencia,
o fuera de una sentencia compuesta.
</p>
<p><code>%%</code> se puede utilizar con <code>batch</code> y <code>load</code>, manteniendo en ambos
casos el mismo significado que en el modo interactivo.
</p>
<p>Véase también <code>%</code>
</p>
<p>Ejemplos:
</p>
<p>Los siguientes dos ejemplos devuelven el mismo resultado.
</p>
<pre class="example">(%i1) block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
                               21
(%o1)                          --
                               2
(%i2) block ([prev], prev: integrate (x^5, x),
               ev (prev, x=2) - ev (prev, x=1));
                               21
(%o2)                          --
                               2

</pre>
<p>Una sentencia compuesta puede contener otras sentencias compuestas.
Independientemente de que una sentencia sea simple o compuesta, <code>%%</code> es 
el valor de la sentencia previa.
</p>
<pre class="example">(%i3) block (block (a^n, %%*42), %%/6);
                                 n
(%o3)                         7 a
</pre>
<p>Dentro de una sentencia compuesta, el valor de <code>%%</code> puede inspeccionarse
en un punto de interrupción que se abra ejecutando la función <code>break</code>.
Por ejemplo, escribiendo <code>%%;</code> en el siguiente ejemplo se obtiene <code>42</code>.
</p>
<pre class="example">(%i4) block (a: 42, break ())$

Entering a Maxima break point. Type 'exit;' to resume.
_%%;
42
_
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>%th</b><i> (<var>i</var>)</i>
<a name="IDX17"></a>
</dt>
<dd><p>Es el valor de la expresión de la <var>i</var>-ésima salida anterior.
Esto es, si la siguiente expresión a calcular es la salida <var>n</var>-ésima,
<code>%th (<var>m</var>)</code> es la salida  (<var>n</var> - <var>m</var>)-ésima.
</p>
<p><code>%th</code> es reconocido por <code>batch</code> y <code>load</code>, interpretándose
de la misma manera que se acaba de indicar. Cuando un fichero es procesado
por <code>load</code>, <code>%th</code> se refiere a los cálculos más recientes;
<code>%th</code> no hace referencia a las expresiones de salida incluidas en el
propio fichero que se está procesando.
</p>
<p>Véanse también <code>%</code> y <code>%%</code>
</p>
<p>Ejemplo:
</p>
<p><code>%th</code> es útil en ficheros <code>batch</code> para hacer referencia a grupos de resultados
recién obtenidos.  En este ejemplo se asigna a <code>s</code> la suma de los cinco resultados.
</p>
<pre class="example">(%i1) 1;2;3;4;5;
(%o1)                           1
(%o2)                           2
(%o3)                           3
(%o4)                           4
(%o5)                           5
(%i6) block (s: 0, for i:1 thru 5 do s: s + %th(i), s);
(%o6)                          15
</pre></dd></dl>



<dl>
<dt><u>Símbolo especial:</u> <b>?</b>
<a name="IDX18"></a>
</dt>
<dd><p>Como prefijo de una función o nombre de variable, <code>?</code> significa que el nombre es de Lisp, no de Maxima.
Por ejemplo, <code>?round</code> representa la función de Lisp <code>ROUND</code>.
Véase <code>Lisp y Maxima</code> para más información.
</p>
<p>La notación <code>? word</code> (un símbolo de interrogación
seguido de una palabra y separados por un espacio)
equivale a <code>describe (&quot;word&quot;)</code>.
El símbolo de interrogación debe escribirse al
comienzo de la línea de entrada; en caso contrario
no se reconoce como una solicitud de documentación.
</p>
</dd></dl>

<dl>
<dt><u>Símbolo especial:</u> <b>??</b>
<a name="IDX19"></a>
</dt>
<dd><p>La notación <code>?? palabra</code> (<code>??</code> seguido de un espacio
y una palabra) equivale a <code>describe(&quot;palabra&quot;, inexact)</code>.
El símbolo de interrogación debe escribirse al
comienzo de la línea de entrada; en caso contrario
no se reconoce como una solicitud de documentación.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>inchar</b>
<a name="IDX20"></a>
</dt>
<dd><p>Valor por defecto: <code>%i</code>
</p>
<p>La variable <code>inchar</code> es el prefijo de las etiquetas de las
expresiones introducidas por el usuario. Maxima crea automáticamente 
una etiqueta para cada expresión de entrada concatenando <code>inchar</code> 
y <code>linenum</code>.
</p>
<p>A <code>inchar</code> se le puede asignar cualquier símbolo 
o cadena, no necesariamente un caracácter sencillo. Puesto que
internamente Maxima solo tiene en cuenta el primer carácter del
prefijo, los prefijos <code>inchar</code>, <code>outchar</code> y <code>linechar</code>
deben comenzar con caracteres diferentes; en caso contrario, sentencias
como <code>kill(inlables)</code> pueden dar resultados inesperados.
</p>
<p>Véase también <code>labels</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) inchar: &quot;input&quot;;
(%o1)                         input
(input2) expand((a+b)^3);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(input3)
</pre>
</dd></dl>


<dl>
<dt><u>Variable del sistema:</u> <b>infolists</b>
<a name="IDX21"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>infolists</code> es una lista con los nombres de todas las listas que guardan información sobre Maxima. Estas son:
</p>
<dl compact="compact">
<dt> <code>labels</code></dt>
<dd><p>Todas las etiquetas <code>%i</code>, <code>%o</code> y <code>%t</code> con valores asignados.
</p></dd>
<dt> <code>values</code></dt>
<dd><p>Todos los átomos que son variables de usuario, no opciones de Maxima creadas con  <code>:</code> o <code>::</code>.
</p></dd>
<dt> <code>functions</code></dt>
<dd><p>Todas las funciones de usuario creadas con <code>:=</code> o <code>define</code>.
</p></dd>
<dt> <code>arrays</code></dt>
<dd><p>Arreglos declarados y no declarados, creados por <code>:</code>, <code>::</code> o <code>:=</code>.
</p></dd>
<dt> <code>macros</code></dt>
<dd><p>Cualquier macro definida por el usuario.
</p></dd>
<dt> <code>myoptions</code></dt>
<dd><p>Todas las opciones inicializadas por el usuario, independientemente de que posteriormente hayan sido devueltas a sus valores por defecto.
</p></dd>
<dt> <code>rules</code></dt>
<dd><p>Reglas de patrones y simplificación definidas por el usuario, creadas con <code>tellsimp</code>, <code>tellsimpafter</code>, <code>defmatch</code> o <code>defrule</code>.
</p></dd>
<dt> <code>aliases</code></dt>
<dd><p>Átomos que tienen un &quot;alias&quot; definido por el usuario, creado por las funciones <code>alias</code>, <code>ordergreat</code> o <code>orderless</code> o por haber declarado el átomo como <code>noun</code> (nombre) con <code>declare</code>.
</p></dd>
<dt> <code>dependencies</code></dt>
<dd><p>Átomos que tienen dependencias funcionales, creados por las funciones <code>depends</code> o <code>gradef</code>.
</p></dd>
<dt> <code>gradefs</code></dt>
<dd><p>Funciones que tienen derivadas definidas por el usuario, creadas por la función <code>gradef</code>.
</p></dd>
<dt> <code>props</code></dt>
<dd><p>Todos los átomos que tengan cualquier propiedad que no sea de las mencionadas hasta ahora, como las establecidas por <code>atvalue</code>, <code>matchdeclare</code>, etc., así como propiedadas especificadas en la función <code>declare</code>.
</p></dd>
<dt> <code>let_rule_packages</code></dt>
<dd><p>Todos los paquetes de reglas <code>let</code> definidos por el usuario, junto con el paquete especial <code>default_let_rule_package</code>; <code>default_let_rule_package</code> es el nombre del paquete de reglas utilizado cuando no se use ningún otro especificado por el usuario.
</p></dd>
</dl>

</dd></dl>



<dl>
<dt><u>Función:</u> <b>kill</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX22"></a>
</dt>
<dt><u>Función:</u> <b>kill</b><i> (labels)</i>
<a name="IDX23"></a>
</dt>
<dt><u>Función:</u> <b>kill</b><i> (inlabels, outlabels, linelabels)</i>
<a name="IDX24"></a>
</dt>
<dt><u>Función:</u> <b>kill</b><i> (<var>n</var>)</i>
<a name="IDX25"></a>
</dt>
<dt><u>Función:</u> <b>kill</b><i> ([<var>m</var>, <var>n</var>])</i>
<a name="IDX26"></a>
</dt>
<dt><u>Función:</u> <b>kill</b><i> (values, functions, arrays, ...)</i>
<a name="IDX27"></a>
</dt>
<dt><u>Función:</u> <b>kill</b><i> (all)</i>
<a name="IDX28"></a>
</dt>
<dt><u>Función:</u> <b>kill</b><i> (allbut (<var>a_1</var>, ..., <var>a_n</var>))</i>
<a name="IDX29"></a>
</dt>
<dd><p>Elimina todas las asignaciones (valor, función, arreglo o regla) hechas a los
argumentos <var>a_1</var>, ..., <var>a_n</var>.
Un argumento <var>a_k</var> puede ser un símbolo o el elemento
de un array. Si <var>a_k</var> es elemento de un array, <code>kill</code> elimina la
asignación hecha a este elemento sin afectar al resto del array.
</p>
<p>Se reconocen varios argumentos especiales. 
Se pueden combinar diferentes clases de argumentos, 
como por ejemplo, <code>kill (inlabels, functions, allbut (foo, bar))</code>.
</p>
<p>La instrucción <code>kill (labels)</code> borra todas las asignaciones asociadas
a las etiquetas de entrada, de salida e intermedias creadas hasta el
momento. La instrucción <code>kill (inlabels)</code> elimina únicamente
las asignaciones de las etiquetas de entrada que comienzan con el
valor actual de <code>inchar</code>. Del mismo modo, <code>kill (outlabels)</code>
elimina únicamente las asignaciones de las etiquetas de salida
que comienzan con el valor actual de <code>outchar</code>. Finalmente,
<code>kill (linelabels)</code> elimina únicamente las asignaciones
de las etiquetas de las expresiones intermedias
que comienzan con el valor actual de <code>linechar</code>.
</p>
<p>La instrucción <code>kill (<var>n</var>)</code>, siendo <var>n</var> un entero,
elimina las asignaciones de las últimas <var>n</var> etiquetas, tanto
de entrada como de salida.
</p>
<p>La instrucción <code>kill ([<var>m</var>, <var>n</var>])</code> elimina las asignaciones
hechas a las etiquetas de entrada y salida desde la <var>m</var> hasta la<var>n</var>.
</p>
<p>La instrucción <code>kill (<var>infolist</var>)</code>, siendo <var>infolist</var> 
cualquier elemento de <code>infolists</code> (como <code>values</code>, <code>functions</code> 
o <code>arrays</code>), elimina todas las asignaciones hechas a los elementos de
<var>infolist</var>. Véase también <code>infolists</code>.
</p>
<p>La instrucción <code>kill (all)</code> elimina todas las asignaciones de
todas las variables, pero no reinicia las variables globales a sus
valores por defecto. Véase también <code>reset</code>.
</p>
<p>La instrucción <code>kill (allbut (<var>a_1</var>, ..., <var>a_n</var>))</code>
elimina las asignaciones hechas a todas las variables,
excepto a <var>a_1</var>, ..., <var>a_n</var>; la instrucción
<code>kill (allbut (<var>infolist</var>))</code> elimina todas las asignaciones,
excepto las de los elementos de <var>infolist</var>, pudiendo ser <var>infolist</var>
igual a <code>values</code>, <code>functions</code>, <code>arrays</code>, etc.
</p>
<p>La memoria reservada para una asignación no se libera hasta que
no se vacíen todos los símbolos
asociados con esta asignación; por ejemplo, para liberar la memoria
del valor de un símbolo es necesario eliminar tanto
la asignación de la etiqueta de salida que muestra el resultado,
como la del propio símbolo.
</p>
<p>La función <code>kill</code> no evalua sus argumentos. 
El operador comilla-comilla, <code>''</code>, obliga a que se realice la evaluación.
</p>
<p>La llamada <code>kill (<var>symbol</var>)</code> elimina todas las propiedades de <var>symbol</var>.
Por el contrario, <code>remvalue</code>, <code>remfunction</code>, <code>remarray</code> y <code>remrule</code>
eliminan propiedades específicas. 
</p>
<p><code>kill</code> siempre devuelve <code>done</code>, incluso cuando alguno de sus 
argumentos carecía de asignación previa. 
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>labels</b><i> (<var>symbol</var>)</i>
<a name="IDX30"></a>
</dt>
<dt><u>Variable del sistema:</u> <b>labels</b>
<a name="IDX31"></a>
</dt>
<dd><p>Retorna la lista de etiquetas de entrada, salida o de expresiones intermedias las cuales empiezan con <var>symbol</var>. 
Típicamente <var>symbol</var> es el valor de las variables <code>inchar</code>, <code>outchar</code> o <code>linechar</code>. 
El caractér de etiqueta puede ser pasado con o sin signo de porcentaje, 
así, por ejemplo, <code>i</code> y <code>%i</code> producen el mismo resultado.  
</p>
<p>Si ninguna etiqueta empieza con <var>symbol</var>, <code>labels</code> retorna a una
lista vacía. 
</p>
<p>La función <code>labels</code> no evalua su argumento.
El operador comilla-comilla, <code>''</code>, obliga a que se realice la evaluación.
Por ejemplo, 
<code>labels (''inchar)</code> devuelve las etiquetas de entrada que empiezan con el caractér de etiqueta de entrada actual. 
</p>
<p>La variable <code>labels</code> es una lista de las etiquetas de entrada, salida y expresiones intermedias, incluyendo todas las etiquetas anteriores en el caso de que <code>inchar</code>, <code>outchar</code> o <code>linechar</code> hayan sido redefinidas. 
</p>
<p>Por defecto, Maxima muestra el resultado de cada expresión introducida por el usuario, asignando al resultado una etiqueta de salida. 
La salida (es decir el resultado) puede ser suprimida terminando la expresión de entrada con un <code>$</code> (signo de dólar) en vez de un <code>;</code> (punto y coma). 
En este caso, se crea la etiqueta de salida y se le asigna el resultado, aunque éste no se muestre; aún así, la etiqueta puede ser referenciada de la misma forma que se hace con aquéllas cuyos resultados sí son mostrados.
</p>
<p>Véanse también: <code>%</code>, <code>%%</code> y <code>%th</code>. 
</p>
<p>Las etiquetas de expresiones intermedias pueden ser generadas por algunas funciones. El interruptor <code>programmode</code> controla si <code>solve</code> y algunas otras funciones generan etiquetas de expresiones intermedias en vez de retornar una lista de expresiones. 
Algunas otras funciones, tales como <code>ldisplay</code>, siempre generan etiquetas de expresiones intermedias. 
</p> 

<p>Véase también: <code>inchar</code>, <code>outchar</code>, <code>linechar</code> y <code>infolists</code>.
</p>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>linechar</b>
<a name="IDX32"></a>
</dt>
<dd><p>Valor por defecto: <code>%t</code>
</p>
<p>La variable <code>linechar</code> es el prefijo de las etiquetas que
genera Maxima para expresiones intermedias. Cuando sea necesario,
Maxima creará una etiqueta para cada expresión intermedia 
concatenando <code>linechar</code> y <code>linenum</code>.
</p>
<p>A <code>linechar</code> se le puede asignar cualquier símbolo 
o cadena, no necesariamente un caracácter sencillo. Puesto que
internamente Maxima solo tiene en cuenta el primer carácter del
prefijo, los prefijos <code>inchar</code>, <code>outchar</code> y <code>linechar</code>
deben comenzar con caracteres diferentes; en caso contrario, sentencias
como <code>kill(inlables)</code> pueden dar resultados inesperados.
</p>
<p>Las expresiones intermedias pueden ser mostradas o no.
Véanse también <code>programmode</code> y <code>labels</code>.
</p>
</dd></dl>



<dl>
<dt><u>Variable del sistema:</u> <b>linenum</b>
<a name="IDX33"></a>
</dt>
<dd><p>El número de la línea del par de expresiones de entrada y salida actuales. 
</p></dd></dl>



<dl>
<dt><u>Variable del sistema:</u> <b>myoptions</b>
<a name="IDX34"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p><code>myoptions</code> es la lista de todas las opciones que nunca fueron reconfiguradas por el usuario, aunque éstas hayan sido reconfiguradas a su valor por defecto. 
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>nolabels</b>
<a name="IDX35"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>nolabels</code> vale <code>true</code>,
las etiquetas de entrada y salida 
(<code>%i</code> y <code>%o</code>, respectivamente)
son mostradas, pero a éstas no se les 
asignan los resultados; además, las etiquetas no se
incorporan a la lista <code>labels</code>.
Puesto que a las etiquetas no se les asignan resultados, 
el colector de basura puede recuperar la memoria ocupada
por éstos.
</p>
<p>En el caso contrario, a las etiquetas de entrada y salida se les asignan los resultados correspondientes y son añadidas a la lista <code>labels</code>.
</p>
<p>Las etiquetas de expresiones intermedias (<code>%t</code>) no se ven afectadas por la variable <code>nolabels</code>;
independientemente de que <code>nolabels</code> valga <code>true</code> o <code>false</code>, a las etiquetas de expresiones intermedias se les asignan siempre valores, además de ser añadidas a la lista <code>labels</code>.
</p>
<p>Véanse también <code>batch</code>, <code>batchload</code> y <code>labels</code>. 
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>optionset</b>
<a name="IDX36"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>optionset</code> tiene como valor <code>true</code>, Maxima imprime un
mensaje cada vez que una opción de Maxima es reconfigurada. Esto es 
muy útil si el usuario duda con frecuencia de la correctitud de alguna
opción y quiere estar seguro de la variable a la que él asignó un
valor fue verdaramente una variable opción (o interruptor). 
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) optionset:true;
assignment: assigning to option optionset
(%o1)                         true
(%i2) gamma_expand:true;
assignment: assigning to option gamma_expand
(%o2)                         true
</pre></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>outchar</b>
<a name="IDX37"></a>
</dt>
<dd><p>Valor por defecto: <code>%o</code>
</p>
<p>La variable <code>outchar</code> es el prefijo de las etiquetas de las 
expresiones calculadas por Maxima. Maxima crea automáticamente 
una etiqueta para cada expresión calculada concatenando <code>outchar</code>
y <code>linenum</code>.
</p>
<p>A <code>outchar</code> se le puede asignar cualquier símbolo 
o cadena, no necesariamente un caracácter sencillo. Puesto que
internamente Maxima solo tiene en cuenta el primer carácter del
prefijo, los prefijos <code>inchar</code>, <code>outchar</code> y <code>linechar</code>
deben comenzar con caracteres diferentes; en caso contrario, sentencias
como <code>kill(inlables)</code> pueden dar resultados inesperados.
</p>
<p>Véase también <code>labels</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) outchar: &quot;output&quot;;
(output1)                    output
(%i2) expand((a+b)^3);
                     3        2      2      3
(output2)           b  + 3 a b  + 3 a  b + a
(%i3)
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>playback</b><i> ()</i>
<a name="IDX38"></a>
</dt>
<dt><u>Función:</u> <b>playback</b><i> (<var>n</var>)</i>
<a name="IDX39"></a>
</dt>
<dt><u>Función:</u> <b>playback</b><i> ([<var>m</var>, <var>n</var>])</i>
<a name="IDX40"></a>
</dt>
<dt><u>Función:</u> <b>playback</b><i> ([<var>m</var>])</i>
<a name="IDX41"></a>
</dt>
<dt><u>Función:</u> <b>playback</b><i> (input)</i>
<a name="IDX42"></a>
</dt>
<dt><u>Función:</u> <b>playback</b><i> (slow)</i>
<a name="IDX43"></a>
</dt>
<dt><u>Función:</u> <b>playback</b><i> (time)</i>
<a name="IDX44"></a>
</dt>
<dt><u>Función:</u> <b>playback</b><i> (grind)</i>
<a name="IDX45"></a>
</dt>
<dd><p>Muestra las entradas, salidas y expresiones intermedias 
sin recalcularlas. 
<code>playback</code> sólo muestra las expresiones asociadas con etiquetas; 
cualquier otra salida (tal como texto impreso por <code>print</code> o <code>describe</code>, o mensajes de error) no es mostrada. 
Véase también: <code>labels</code>. 
</p>
<p><code>playback</code> no evalua sus argumentos. 
El operador comilla-comilla, <code>''</code>, obliga a que se realice la evaluación.
<code>playback</code> siempre devuelve <code>done</code>. 
</p>
<p><code>playback ()</code> (sin argumentos) muestra todas las entradas, salidas y expresiones intermedias generadas hasta el momento. 
Una expresión de salida es mostrada incluso si ésta fue suprimida por el caracter de terminación <code>$</code>, cuando fue originalmente calculada. 
</p>
<p><code>playback (<var>n</var>)</code>  muestra las <var>n</var> expresiones más recientes. Cada entrada, salida y expresión intermedia cuenta como una. 
</p>
<p><code>playback ([<var>m</var>, <var>n</var>])</code> muestra entradas, salidas y expresiones intermedias con los números desde <var>m</var> hasta <var>n</var>, ambos inclusive. 
</p>
<p><code>playback ([<var>m</var>])</code> es equivalente a <code>playback ([<var>m</var>, <var>m</var>])</code>;
esto usualmente imprime un par de expresiones de entrada y salida. 
</p>
<p><code>playback (input)</code> muestra todas las expresiones de entrada generadas hasta el momento. 
</p>
<p><code>playback (slow)</code> hace pausas entre expresiones y
espera a que el usuario pulse la tecla <code>enter</code> para continuar. 
Esto es un comportamiento similar a <code>demo</code>. 
</p>
<p><code>playback (slow)</code> es muy útil en conjunción con <code>save</code> o
<code>stringout</code> cuando se crea un archivo secundario de almacenamiento con el objetivo de elegir cuidadosamente las expresiones realmente útiles. 
</p>

<p><code>playback (time)</code> muestra el tiempo de computo por cada expresión. 
</p>

<p><code>playback (grind)</code> muestra las expresiones de entrada 
en el mismo formato como la función <code>grind</code>. 
Las expresiones de salida no se ven afectadas por la opción 
<code>grind</code>. 
Vea <code>grind</code>. 
Los argumentos pueden ser combinados, por ejemplo, 
<code>playback ([5, 10], grind, time, slow)</code>.
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>prompt</b>
<a name="IDX46"></a>
</dt>
<dd><p>Valor por defecto: <code>_</code>
</p>
<p><code>prompt</code> es el símbolo del prompt de la función <code>demo</code>, 
del modo <code>playback (slow)</code> y del bucle de interrupción de Maxima (el que se invoca con <code>break</code>). 
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>quit</b><i> ()</i>
<a name="IDX47"></a>
</dt>
<dd><p>Termina una sesión de Maxima. 
Nótese que la función debe ser invocada como <code>quit();</code> o <code>quit()$</code>, no como <code>quit</code>. 
</p>
<p>Para parar un cálculo muy demorado 
pulse <code>Control-C</code>. 
La acción por defecto es retornar a prompt de Maxima. 
Si <code>*debugger-hook*</code> tiene como valor <code>nil</code>,
pulsar <code>Control-C</code> abrirá el depurador de Lisp. 
Vea también: <code>debugging</code>. 
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>read</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX48"></a>
</dt>
<dd><p>Imprime <var>expr_1</var>, ..., <var>expr_n</var> y a continuación lee una expresión desde la consola y devuelve la expresión evaluada. La expresión termina con un punto y coma <code>;</code> o con el símbolo de dólar <code>$</code>.
</p>
<p>Véase también <code>readonly</code>.
</p>
<pre class="example">(%i1) foo: 42$ 
(%i2) foo: read (&quot;foo vale&quot;, foo, &quot; -- nuevo valor.&quot;)$
foo vale 42  -- nuevo valor. 
(a+b)^3;
(%i3) foo;
                                     3
(%o3)                         (b + a)
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>readonly</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX49"></a>
</dt>
<dd><p>Imprime <var>expr_1</var>, ..., <var>expr_n</var> y a continuación lee una expresión desde la consola y devuelve la expresión sin evaluar. La expresión termina con un punto y coma <code>;</code> o con el símbolo de dólar <code>$</code>.
</p>
<pre class="example">(%i1) aa: 7$
(%i2) foo: readonly (&quot;Introducir expresion:&quot;);
Introducir expresion: 
2^aa;
                                  aa
(%o2)                            2
(%i3) foo: read (&quot;Introducir expresion:&quot;);
Introducir expresion: 
2^aa;
(%o3)                            128
</pre>
<p>Véase también <code>read</code>.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>reset</b><i> ()</i>
<a name="IDX50"></a>
</dt>
<dd><p>Reconfigura muchas variables y opciones globales y algunas otras variables a sus valores por defecto. 
</p>
<p><code>reset</code> procesa las variables que se encuentran en la lista Lisp 
<code>*variable-initial-values*</code>. 
La macro Lisp <code>defmvar</code> pone las variables en ésta lista (entre otras acciones). 
Muchas, pero no todas, las variables y opciones globales son definidas por <code>defmvar</code>, y algunas variables definidas por <code>defmvar</code> no son ni variables ni opciones globales. 
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>showtime</b>
<a name="IDX51"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>showtime</code> tiene como valor <code>true</code>, el tiempo de cálculo y el tiempo de retardo se imprimen junto con la salida de cada expresión. 
</p>
<p>El tiempo de cálculo se almacena siempre, de manera que <code>time</code> y <code>playback</code> puedan mostrar el tiempo de cálculo incluso cuando <code>showtime</code> vale <code>false</code>.
</p>
<p>Véase también <code>timer</code>.
</p>
</dd></dl>


<dl>
<dt><u>Function:</u> <b>to_lisp</b><i> ()</i>
<a name="IDX52"></a>
</dt>
<dd><p>Entra en el intérprete Lisp bajo Maxima. <code>(to-maxima)</code> retorna de nuevo a Maxima. 
</p>
<p>Ejemplo:
</p>
<p>Define una función y entra en el nivel Lisp. La definición
se consulta en la lista de propiedades, luego se extrae la definición
de la función, se factoriza y almacena el resultado en la variable <code>$result</code>.
Esta variable se puede utilizar luego una vez se haya vuelto al nivel
de Maxima.
</p>
<pre class="example">(%i1) f(x):=x^2+x;
                                         2
(%o1)                           f(x) := x  + x
(%i2) to_lisp();
Type (to-maxima) to restart, ($quit) to quit Maxima.

MAXIMA&gt; (symbol-plist '$f)
(MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X) ((MPLUS) ((MEXPT) $X 2) $X))))
MAXIMA&gt; (setq $result ($factor (caddr (mget '$f 'mexpr))))
((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
MAXIMA&gt; (to-maxima)
Returning to Maxima
(%o2)                                true
(%i3) result;
(%o3)                              x (x + 1)
</pre></dd></dl>



<dl>
<dt><u>Variable del sistema:</u> <b>values</b>
<a name="IDX53"></a>
</dt>
<dd><p>Valor inicial: <code>[]</code>
</p>
<p><code>values</code> es una lista de todas las variables que el usuario ha creado
(no incluye las opciones de Maxima ni los interruptores). 
La lista comprende los símbolos a los que se ha asignado un
valor mediante <code>:</code> o <code>::</code>.
</p>
<p>Si el valor de una variable se borra con cualquiera de las instrucciones
<code>kill</code>, <code>remove</code> o <code>remvalue</code>, dicha variable desaparece
de la lista <code>values</code>.
</p>
<p>Véase <code>functions</code> para una lista de funciones definidas por el
usuario.
</p>
<p>Ejemplos:
</p>
<p>Primero, <code>values</code> muestra los símbolos <code>a</code>, 
<code>b</code> y <code>c</code>, pero no <code>d</code>, pues no tiene valor asignado,
ni la función de usuario <code>f</code>. Luego los valores de las variables se
borran y <code>values</code> queda como una lista vacía.
</p>
<pre class="example">(%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                  2
(%o1)                     [99, 9, 90, d, f(x) := x ]
(%i2) values;
(%o2)                              [a, b, c]
(%i3) [kill(a), remove(b,value), remvalue(c)];
(%o3)                          [done, done, [c]]
(%i4) values;
(%o4)                                 []
</pre>
</dd></dl>













<hr size="6">
<a name="Funciones-y-variables-para-la-impresi_00f3n"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC16" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC18" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC7" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC7" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC17"></a>
<h2 class="section"> 4.3 Funciones y variables para la impresión </h2>


<dl>
<dt><u>Variable opcional:</u> <b>%edispflag</b>
<a name="IDX54"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>%edispflag</code> vale <code>true</code>, Maxima muestra <code>%e</code> elevado
a un exponente negativo como un cociente. Por ejemplo, <code>%e^-x</code> se
muestra como <code>1/%e^x</code>. Véase también <code>exptdispflag</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) %e^-10;
                               - 10
(%o1)                        %e
(%i2) %edispflag:true$
(%i3) %e^-10;
                               1
(%o3)                         ----
                                10
                              %e
</pre></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>absboxchar</b>
<a name="IDX55"></a>
</dt>
<dd><p>Valor por defecto: <code>!</code>
</p>
<p>La variable <code>absboxchar</code> es el carácter utilizado para representar el valor absoluto de una expresión que ocupa más de una línea de altura.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) abs((x^3+1));
                            ! 3    !
(%o1)                       !x  + 1!
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>disp</b><i> (<var>expr_1</var>, <var>expr_2</var>, ...)</i>
<a name="IDX56"></a>
</dt>
<dd><p>Es como <code>display</code> pero sólo se muestran los valores de
los argumentos, no las ecuaciones. Es útil para argumentos 
complicados que no tienen nombre o en situaciones en las que 
solamente es de interés el valor del argumento pero no su nombre.
</p>
<p>Véanse también <code>ldisp</code> y <code>print</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) b[1,2]:x-x^2$
(%i2) x:123$
(%i3) disp(x, b[1,2], sin(1.0));
                               123

                                  2
                             x - x

                        .8414709848078965

(%o3)                         done
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>display</b><i> (<var>expr_1</var>, <var>expr_2</var>, ...)</i>
<a name="IDX57"></a>
</dt>
<dd><p>Muestra las ecuaciones cuyos miembros izquierdos son 
<var>expr_i</var> sin evaluar y cuyos miembros derechos son los 
valores de las expresiones. Esta función es útil en los 
bloques y en las sentencias <code>for</code> para mostrar resultados 
intermedios.  Los argumentos de <code>display</code> suelen ser átomos, 
variables subindicadas o llamadas a funciones.
</p>
<p>Véanse también <code>ldisplay</code>, <code>disp</code> y <code>ldisp</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) b[1,2]:x-x^2$
(%i2) x:123$
(%i3) display(x, b[1,2], sin(1.0));
                             x = 123

                                      2
                         b     = x - x
                          1, 2

                  sin(1.0) = .8414709848078965

(%o3)                         done
</pre></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>display2d</b>
<a name="IDX58"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>display2d</code> vale <code>false</code>, la salida por consola es
una cadena unidimensional, en lugar de una expresión bidimensional.
</p>
<p>Véase también <code>leftjust</code> para cambiar la justificación a
la izquierda o el centrado de la ecuación.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) x/(x^2+1);
                               x
(%o1)                        ------
                              2
                             x  + 1
(%i2) display2d:false$
(%i3) x/(x^2+1);
(%o3) x/(x^2+1)
</pre></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>display_format_internal</b>
<a name="IDX59"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>display_format_internal</code> vale <code>true</code>,
las expresiones se muestran sin ser transformadas de manera que oculten su representación matemática interna. Se representa lo que la función <code>inpart</code> devolvería, en oposición a <code>part</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">User     part       inpart
a-b;      a - b     a + (- 1) b

           a            - 1
a/b;       -         a b
           b
                       1/2
sqrt(x);   sqrt(x)    x

          4 X        4
X*4/3;    ---        - X
           3         3
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>dispterms</b><i> (<var>expr</var>)</i>
<a name="IDX60"></a>
</dt>
<dd><p>Muestra <var>expr</var> en partes, una debajo de la otra.
Esto es, primero se muestra el operador de <var>expr</var>, luego 
cada término si se trata de una suma, o cada factor si es un 
producto, o si no se muestra separadamente la parte de una expresión 
más general. Es útil si <var>expr</var> es demasiado grande para 
representarla de otra forma.  Por ejemplo, si <code>P1</code>, <code>P2</code>, ...  
son expresiones muy grandes, entonces el programa de representación 
puede superar el espacio de almacenamiento tratando de mostrar 
<code>P1 + P2 + ...</code> todo junto.  Sin embargo, <code>dispterms (P1 + P2 + ...)</code> 
muestra <code>P1</code>, debajo  <code>P2</code>, etc.  Cuando una expresión exponencial 
es demasiado ancha para ser representada como <code>A^B</code>, si no se utiliza 
<code>dispterms</code>, entonces aparecerá como <code>expt (A, B)</code> (o como 
<code>ncexpt (A, B)</code>, en lugar de <code>A^^B</code>).
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) dispterms(2*a*sin(x)+%e^x);

+

2 a sin(x)

  x
%e

(%o1)                         done
</pre></dd></dl>


<dl>
<dt><u>Símbolo especial:</u> <b>expt</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX61"></a>
</dt>
<dt><u>Símbolo especial:</u> <b>ncexpt</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX62"></a>
</dt>
<dd><p>Si una expresión exponencial es demasiado ancha para ser mostrada como <code><var>a</var>^<var>b</var></code> aparecerá como <code>expt (<var>a</var>, <var>b</var>)</code> (o como <code>ncexpt (<var>a</var>, <var>b</var>)</code> en lugar de <code><var>a</var>^^<var>b</var></code>).
</p>
<p>Las funciones <code>expt</code> y <code>ncexpt</code> no se reconocen en una entrada.
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>exptdispflag</b>
<a name="IDX63"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>exptdispflag</code> vale <code>true</code>, Maxima muestra las expresiones con 
exponentes negativos como cocientes. Véase también <code>%edispflag</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) exptdispflag:true;
(%o1)                         true
(%i2) 10^-x;
                                1
(%o2)                          ---
                                 x
                               10
(%i3) exptdispflag:false;
(%o3)                         false
(%i4) 10^-x;
                                - x
(%o4)                         10
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>grind</b><i> (<var>expr</var>)</i>
<a name="IDX64"></a>
</dt>
<dt><u>Variable opcional:</u> <b>grind</b>
<a name="IDX65"></a>
</dt>
<dd><p>La función <code>grind</code> imprime <var>expr</var>
en la consola en un formato admisible como entrada para Maxima. La función 
<code>grind</code> devuelve siempre <code>done</code>.
</p>
<p>Cuando <var>expr</var> es el nombre de una función o macro, <code>grind</code>
muestra la definición de la función o de la macro en lugar de sólo
su nombre.
</p>
<p>Véase también <code>string</code>, que devuelve una cadena en lugar de imprimir la salida. La función
<code>grind</code> intenta imprimir la expresión de forma que sea lago más sencilla de leer que la salida de <code>string</code>.
</p>
<p>Cuando la variable <code>grind</code> vale <code>true</code>,
la salida de <code>string</code> y <code>stringout</code> tienen el mismo formato que la de <code>grind</code>;
en caso contrario no se formatea la salida de esas funciones.
El valor por defecto de la variable <code>grind</code> es <code>false</code>.
</p>
<p>La variable <code>grind</code> también se puede utilizar como  argumento en <code>playback</code>.
Si <code>grind</code> está presente,
<code>playback</code> imprime las expresiones de entrada en el mismo formato que lo hace la función <code>grind</code>;
en caso contrario no se formatean la expresiones de entrada.
</p>
<p>La función <code>grind</code> evalúa sus argumentos.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) aa + 1729;
(%o1)                       aa + 1729
(%i2) grind (%);
aa+1729$
(%o2)                         done
(%i3) [aa, 1729, aa + 1729];
(%o3)                 [aa, 1729, aa + 1729]
(%i4) grind (%);
[aa,1729,aa+1729]$
(%o4)                         done
(%i5) matrix ([aa, 17], [29, bb]);
                           [ aa  17 ]
(%o5)                      [        ]
                           [ 29  bb ]
(%i6) grind (%);
matrix([aa,17],[29,bb])$
(%o6)                         done
(%i7) set (aa, 17, 29, bb);
(%o7)                   {17, 29, aa, bb}
(%i8) grind (%);
{17,29,aa,bb}$
(%o8)                         done
(%i9) exp (aa / (bb + 17)^29);
                                aa
                            -----------
                                     29
                            (bb + 17)
(%o9)                     %e
(%i10) grind (%);
%e^(aa/(bb+17)^29)$
(%o10)                        done
(%i11) expr: expand ((aa + bb)^10);
         10           9        2   8         3   7         4   6
(%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
         5   5         6   4         7   3        8   2
 + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
        9        10
 + 10 aa  bb + aa
(%i12) grind (expr);
bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
     +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
     +10*aa^9*bb+aa^10$
(%o12)                        done
(%i13) string (expr);
(%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
+252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
bb+aa^10
(%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
  p : makelist (0, i, 1, length (A))], for i thru n do
  for j : i thru n do
  (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1),
  if i = j then p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]),
  for i thru n do L[i, i] : 1 / p[i],
  for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
(%i15) grind (cholesky);
cholesky(A):=block(
         [n:length(A),L:copymatrix(A),
          p:makelist(0,i,1,length(A))],
         for i thru n do
             (for j from i thru n do
                  (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                   if i = j then p[i]:1/sqrt(x)
                       else L[j,i]:x*p[i])),
         for i thru n do L[i,i]:1/p[i],
         for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
(%o15)                        done
(%i16) string (fundef (cholesky));
(%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
n do (for j from i+1 thru n do L[i,j]:0),L)
</pre></dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>ibase</b>
<a name="IDX66"></a>
</dt>
<dd><p>Valor por defecto: <code>10</code>
</p>
<p><code>ibase</code> es la base en la que Maxima lee valores enteros.
</p>
<p>A <code>ibase</code> se le puede asignar cualquier entero entre
2 y 36 (base decimal), ambos inclusive.
Si <code>ibase</code> es mayor que 10,
las cifras a utilizar serán los dígitos de
0 a 9, junto con las letras del alfabeto A, B, C, ..., 
tantas como sean necesarias para completar la base <code>ibase</code>.
Las letras se interpretarán como cifras sólo cuando el 
primer dígito sea un valor entre 9.
Es indiferente hacer uso de letras mayúsculas o minúsculas.
Las cifras para la base 36, la mayor posible, son los 
dígitos numéricos de 0 a 9 y las letras desde
la A hasta la Z.
</p>
<p>Cualquiera que sea el valor de <code>ibase</code>, si un entero termina
con un punto decimal, se interpretará en base 10.
</p>
<p>Véase también <code>obase</code>.
</p>
<p>Ejemplos:
</p>
<p><code>ibase</code> menor que 10.
</p>
<pre class="example">(%i1) ibase : 2 $
(%i2) obase;
(%o2)                          10
(%i3) 1111111111111111;
(%o3)                         65535
</pre>
<p><code>ibase</code> mayor que 10.
Las letras se interpretan como dígitos sólo
si el primer dígito es una cifra entre 0 y 9.
</p>
<pre class="example">(%i1) ibase : 16 $
(%i2) obase;
(%o2)                          10
(%i3) 1000;
(%o3)                         4096
(%i4) abcd;
(%o4)                         abcd
(%i5) symbolp (abcd);
(%o5)                         true
(%i6) 0abcd;
(%o6)                         43981
(%i7) symbolp (0abcd);
(%o7)                         false
</pre>
<p>Independientemente del valor de <code>ibase</code>, si el entero
termina con un punto decimal, se interpretará en base
diez.
</p>
<pre class="example">(%i1) ibase : 36 $
(%i2) obase;
(%o2)                          10
(%i3) 1234;
(%o3)                         49360
(%i4) 1234.;
(%o4)                         1234
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>ldisp</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX67"></a>
</dt>
<dd><p>Muestra las expresiones <var>expr_1</var>, ..., <var>expr_n</var> en la consola con el formato de salida;
<code>ldisp</code> asigna una etiqueta a cada argumento y devuelve la lista de etiquetas.
</p>
<p>Véanse también <code>disp</code>, <code>display</code> y <code>ldisplay</code>.
</p>
<pre class="example">(%i1) e: (a+b)^3;
                                   3
(%o1)                       (b + a)
(%i2) f: expand (e);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(%i3) ldisp (e, f);
                                   3
(%t3)                       (b + a)

                     3        2      2      3
(%t4)               b  + 3 a b  + 3 a  b + a

(%o4)                      [%t3, %t4]
(%i4) %t3;
                                   3
(%o4)                       (b + a)
(%i5) %t4;
                     3        2      2      3
(%o5)               b  + 3 a b  + 3 a  b + a
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>ldisplay</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX68"></a>
</dt>
<dd><p>Muestra las expresiones <var>expr_1</var>, ..., <var>expr_n</var> en la consola con el formato de salida.
Cad expresión se muestra como una ecuación de la forma <code>lhs = rhs</code>
en la que <code>lhs</code> es uno de los argumentos de <code>ldisplay</code>
y <code>rhs</code> su valor. Normalmente, cada argumento será el nombre de una variable. La función
<code>ldisp</code> asigna una etiqueta a cada ecuación y devuelve la lista de etiquetas.
</p>
<p>Véanse también <code>disp</code>, <code>display</code> y <code>ldisp</code>.
</p>
<pre class="example">(%i1) e: (a+b)^3;
                                   3
(%o1)                       (b + a)
(%i2) f: expand (e);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(%i3) ldisplay (e, f);
                                     3
(%t3)                     e = (b + a)

                       3        2      2      3
(%t4)             f = b  + 3 a b  + 3 a  b + a

(%o4)                      [%t3, %t4]
(%i4) %t3;
                                     3
(%o4)                     e = (b + a)
(%i5) %t4;
                       3        2      2      3
(%o5)             f = b  + 3 a b  + 3 a  b + a
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>linel</b>
<a name="IDX69"></a>
</dt>
<dd><p>Valor por defecto: <code>79</code>
</p>
<p>La variable <code>linel</code> es la anchura (medida en número de caracteres) de la consola que se le da a Maxima para que muestre las expresiones. A <code>linel</code> se le puede asignar cualquier valor, pero si éste es muy pequeño o grande resultará de poca utilidad. El texto que impriman las funciones internas de Maxima, como los mensajes de error y las salidas de la función <code>describe</code>, no se ve afectado por el valor de <code>linel</code>.
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>lispdisp</b>
<a name="IDX70"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>lispdisp</code> vale <code>true</code>, los símbolos de Lisp se muestran precedidos del carácter de interrogación <code>?</code>. En caso contrario, los símbolos de Lisp se muestran sin esta marca.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) lispdisp: false$
(%i2) ?foo + ?bar;
(%o2)                       foo + bar
(%i3) lispdisp: true$
(%i4) ?foo + ?bar;
(%o4)                      ?foo + ?bar
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>negsumdispflag</b>
<a name="IDX71"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>negsumdispflag</code> vale <code>true</code>, <code>x - y</code> se muestra como <code>x - y</code>
en lugar de <code>- y + x</code>.  Dándole el valor <code>false</code> se realiza un análisis adicional para que no se representen de forma muy diferente dos expresiones similares.  Una aplicación puede ser para que <code>a + %i*b</code> y <code>a - %i*b</code> se representen ambas de la misma manera.
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>obase</b>
<a name="IDX72"></a>
</dt>
<dd><p>Valor por defecto: <code>10</code>
</p>
<p><code>obase</code> es la base en la que Maxima imprime los números enteros.
</p>
<p>A <code>obase</code> se le puede asignar cualquier entero entre
2 y 36 (base decimal), ambos inclusive.
Si <code>obase</code> es mayor que 10,
las cifras a utilizar serán los dígitos de
0 a 9, junto con las letras del alfabeto A, B, C, ..., 
tantas como sean necesarias para completar la base <code>obase</code>.
Si el primer dígito resulta ser una letra, se le
añadirá el cero como prefijo.
Las cifras para la base 36, la mayor posible, son los 
dígitos numéricos de 0 a 9 y las letras desde
la A hasta la Z.
</p>
<p>Véase también <code>ibase</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) obase : 2;
(%o1)                          10
(%i2) 2^8 - 1;
(%o10)                      11111111
(%i3) obase : 8;
(%o3)                          10
(%i4) 8^8 - 1;
(%o4)                       77777777
(%i5) obase : 16;
(%o5)                          10
(%i6) 16^8 - 1;
(%o6)                       0FFFFFFFF
(%i7) obase : 36;
(%o7)                          10
(%i8) 36^8 - 1;
(%o8)                       0ZZZZZZZZ
</pre></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>pfeformat</b>
<a name="IDX73"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>pfeformat</code> vale <code>true</code>, una fracción de enteros será mostrada con el carácter de barra inclinada <code>/</code> entre ellos.
</p>

<pre class="example">(%i1) pfeformat: false$
(%i2) 2^16/7^3;
                              65536
(%o2)                         -----
                               343
(%i3) (a+b)/8;
                              b + a
(%o3)                         -----
                                8
(%i4) pfeformat: true$ 
(%i5) 2^16/7^3;
(%o5)                       65536/343
(%i6) (a+b)/8;
(%o6)                      1/8 (b + a)
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>powerdisp</b>
<a name="IDX74"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>powerdisp</code> vale <code>true</code>, se muestran las sumas con sus términos ordenados de menor a mayor potencia. Así, un polinomio se presenta como una serie de potencias truncada con el término constante al principio y el de mayor potencia al final.
</p>
<p>Por defecto, los términos de una suma se muestran en el orden de las potencias decrecientes.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) powerdisp:true;
(%o1)                         true
(%i2) x^2+x^3+x^4;
                           2    3    4
(%o2)                     x  + x  + x
(%i3) powerdisp:false;
(%o3)                         false
(%i4) x^2+x^3+x^4;
                           4    3    2
(%o4)                     x  + x  + x
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>print</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX75"></a>
</dt>
<dd><p>Evalúa y muestra las expresiones  <var>expr_1</var>, ..., <var>expr_n</var> secuencialmente de izquierda a derecha, comenzando la impresión por el borde izquierdo de la consola.
</p>
<p>El valor devuelto por <code>print</code> es el valor de su último argumento. La función <code>print</code> no genera etiquetas para las expresiones intermedias.
</p>
<p>Véanse también <code>display</code>, <code>disp</code>, <code>ldisplay</code> y <code>ldisp</code>, que muestran una expresión por línea, mientras que <code>print</code> trata de mostrar dos o más expresiones por línea.
</p>
<p>Para mostrar el contenido de un archivo véase <code>printfile</code>.
</p>
<pre class="example">(%i1) r: print (&quot;(a+b)^3 is&quot;, expand ((a+b)^3), &quot;log (a^10/b) is&quot;,
      radcan (log (a^10/b)))$
            3        2      2      3
(a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is 

                                              10 log(a) - log(b) 
(%i2) r;
(%o2)                  10 log(a) - log(b)
(%i3) disp (&quot;(a+b)^3 is&quot;, expand ((a+b)^3), &quot;log (a^10/b) is&quot;,
      radcan (log (a^10/b)))$
                           (a+b)^3 is

                     3        2      2      3
                    b  + 3 a b  + 3 a  b + a

                         log (a^10/b) is

                       10 log(a) - log(b)
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>sqrtdispflag</b>
<a name="IDX76"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>sqrtdispflag</code> vale <code>false</code>, hará que <code>sqrt</code> se muestre con el exponente 1/2.
</p></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>stardisp</b>
<a name="IDX77"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>stardisp</code> vale <code>true</code>, la multiplicación se muestra con un asterisco <code>*</code> entre los operandos.
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>ttyoff</b>
<a name="IDX78"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>ttyoff</code> vale <code>true</code>, no se muestran las expresiones resultantes, pero éstas se calculan de todos modos y se les asignan etiquetas. Véase <code>labels</code>.
</p>
<p>El texto que escriban las funciones internas de Maxima, tales como los mensajes de error y las salidas de <code>describe</code>,
no se ven afectadas por <code>ttyoff</code>.
</p>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC7" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_5.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Jaime Villate</em> on <em>diciembre, 30 2014</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
